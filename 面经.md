# Nacos

## Nacos基本原理

​	Spring Cloud的注册中心组件。围绕服务实例注册、实例健康检查、服务实例获取这三个核心来实现的。

### 服务注册基本流程

- 服务实例启动，将自身注册到Nacos注册中心
- 维持与注册中心的心跳
- 注册中心主动发起健康检查
- 服务消费者通过注册中心获取实例，并发起调用

> 注册：
>
> ​	将服务实例的名称，套接字交给注册中心。同一个服务如果有多个实例，需要保证服务名称相同。
>
> 维持心跳与健康检查：
>
> ​	心跳维持策略为每5秒服务实例像Nacos发送一次心跳，携带实例信息(服务名、实例IP、端口等)。
>
> ​	15秒没有心跳，且健康检查失败，认为实例不健康。如果30秒健康检查失败会剔除实例。
>
> 服务发现：
>
> ​	支持两种场景：一、服务消费者向Nacos发送获取某服务的请求，Nacos返回所有可用实例。
>
> ​	二、服务消费者向Nacos订阅某服务，并提交一个监听器。当服务发生变化时，监听器会收到通知，消费者更新本地服务实例列表，以保证所有服务均可用。

### Nacos的数据模型

​	Nacos服务注册表结构为`Map<namespace, Map<group::servicaName, Service>>`。

​	可以理解为Nacos支持用户创建多个环境(dev，prod)，每个环境有自己的namespace，每个环境中可以分组，不同组内的服务名称可以相同。默认分组为DEFAULT_GROUP。



### Nacos服务领域模型

​	通过上述描述，我们知道可以通过三元组定位一个服务。那么，服务模型又是什么。

![](./img/NacosServiceModel.png)

​	服务可以包含多个集群(cluster)，集群中包含多个实例(instance)。

- 在服务级别，保存了健康检查开关、元数据、路由机制、保护阈值等设置。
- 集群保存了健康检查模式、元数据、同步机制等数据。
- 实例保存了该实例的ip、端口、权重、健康检查状态、下线状态、元数据、响应时间。



### 注册中心与配置中心

#### 注册中心

​	微服务一个项目中包含多个模块，各个模块自己作为一个独立的项目，部署在不同的服务器上，彼此之间通过网络进行服务器之间的通信。模块之间在相互调用时，需要知道服务提供方的IP、端口号。如果模块不多，且部署固定，可以直接将被调用方的套接字以硬编码的方式写死在程序中。

​	但是，微服务结构下，通常一个服务都会存在多个实例，部署在不同的机器上，构成了集群。集群中的机器会频繁的增加和减少，于是管理IP和端口号就非常繁琐。

​	注册中心就是为了管理服务的IP和端口号的。每个服务的实例上线时，将自己的IP和端口号发送给注册中心；需要调用别的服务时就向注册中心获取。因此，注册中心只提供两个接口：

- 接收别人发送的ip和端口信息并存储起来。
- 查询并返回相应的IP和端口信息。



#### 配置中心

​	Spring Boot的出现极大地减少了项目的配置难度，但是仍然需要配置。微服务的众多模块都有各自的配置文件，即使两个项目使用的是相同的配置，他们也需要各自持有一份，于是管理配置的难度也十分高。如果某个模块有十几个实例，当它的配置发生变化，就需要手动重启这十几个服务器。

​	配置中心的出现就是为了维护项目的配置文件，包含如下功能：

- 存储配置项
- 提供一个返回配置项的接口
- 通过接口通知应用放弃先前的环境，生成新的环境。

> Nacos作为配置中心时，其配置项可以存储在文件、MySQL、Redis中。



## Nacos中保护阈值的作用是什么

​	假设一个服务有10个实例，其中有5个挂掉了，此时，本来应该由10个实例来处理的流量，现在就全部交给剩余的5个实例来处理。但是，剩余的实例也无法正常处理，最终会被压垮。此时，就可以给服务设定一个保护阈值，取值范围为$[0,1]$，如取0.5，该服务中半数的实例挂掉后，Nacos会在服务调用方调用服务时，将所有的实例都拉取到调用者本地，包括健康的和不健康的实例。然后在本地进行负载均衡地调用，调用的实例可能是健康的实例，也可能是挂掉的实例。通过这样的方法，很好的保护了剩余的健康实例。



## Nacos中的负载均衡是怎样的

​	Nacos的负载均衡，是在进行发现服务时负载均衡。正常情况下，进行服务发现时，会根据服务名称将该服务所有的实例拉取到本地。但是，Nacos提供了一个功能，即在拉取实例时，可以根据*随机选择策略*，只拉取所有实例中的一个。这就是Nacos中的负载均衡。它跟Ribbon中的负载均衡并不冲突，Ribbon是在拉取得到的所有实例上进行负载均衡，是在Nacos负载均衡之后发生的。



## Nacos的就近访问

​	Nacos中一个服务可以包含多个集群，一个集群可以包含多个实例。如果现在某个服务A想要调用服务B，那么Nacos会看调用服务A的实例是属于哪个集群的，并且调用服务B时，那就会调用同样集群下的服务B实例，根据cluster-name来判断两个实例是不是同一个集群，这就是Nacos的就近访问。



## 如何看待CAP理论

​	CAP(Consistency，Availability，Partition Tolerance)，对应一致性，可用性和分区容错性。

- Consistency：系统处于一致状态，即分布式系统中所有节点看到的数据都是相同的。
- Availability：系统必须保证任何时刻，都能处理请求并返回正确的结果，即系统处于可用状态。
- Partition Tolerance：系统在遇到网络分区故障时，仍能够保持正常的工作。即系统能够容忍任意数量的消息丢失或网络分区。
  - 网络分区：网络分区只在分布式集群中，节点之间由于网络不通，导致集群中节点形成不同的子集，子集中节点之间网络互通，而子集与子集之间网络不通。

​	CAP理论可以理解为目前硬件条件下对于分布式架构的一种限制，就是对于一个分布式系统，只能保证AP或CP，而不能同时保证CAP。首先对于一个分布式系统，P，也就是分区容错性是一定要保证的，对于一个分布式系统，得保证在网络出现分区后，分布式系统仍然能工作，所以得保证P。当出现网络分区后，整个分布式系统如果想要保证数据一致性，那么就要损耗系统可用性，或者如果想要保证系统的可用性，就不能保证系统的一致性。这里说的是强一致性，因为如果网络出现问题，分布式系统中的数据就无法进行及时的同步，如果要求强一致性，那么就只能等网络好了之后，数据同步好了之后，才能提供给用户使用，同理，如果要求网络出现后问题，系统要能使用，那就可能数据会不一致，所以对于一个分布式系统，目前来说只能保证CP或AP。



## Nacos中保证的是AP还是CP

​	Nacos既能保证AP，也能保证CP，具体看如何配置。Nacos作为注册中心时才能保证AP或CP，因为作为配置中心时，其数据都存储在一个MySQL中，只有注册中心的数据需要在集群节点之间同步。

​	如果注册的节点是临时节点，那么就是AP，如果是非临时节点，那么就是CP，默认是临时节点。



## 如何理解Nacos中的命名空间

​	命名空间，namespace，在Nacos无论是配置还是服务都是属于一个命名空间的。默认情况下，都属于public命名空间。我们可以在Nacos中新增命名空间，即开辟了一块新的空间用来存储服务和配置。命名空间之间是完全独立的。



## 你认为注册中心应该保证AP还是CP

​	我认为应该保证AP，因为如果保证CP，当我们向注册中心注册实例或移除实例时，都要等待注册中心集群中的数据达到一致后，才算注册或移除成功，而这是比较耗时的，随着业务应用规模的增大，应用频繁的上下线，那么就会导致注册中心的压力比较大，会影响到服务发现的效率以及服务调用了。

​	而如果注册中心是AP的，那么注册中心集群不管出现了什么情况，都是可以提供服务的，就算集群节点之间数据出现了不一致，对于业务应用而言，可能拉取到了一个已经下线了的服务节点，但是现在一般的微服务框架或组件都提供了服务容错和重试功能，也可以避免这个问题，而如果是AP，对于注册中心而言就不需要消耗太多的资源来实时的保证数据一致性了，保证最终一致性就可以了，这样注册中心的压力会小一点。



# Feign

## Feign基本原理

### 什么是Feign

​	Feign可以翻译为假装、伪装。Feign可以将Rest的请求进行隐藏，伪装成类似SpringMVC中的Controller方法一样。使得调用远程服务无需自己拼接url和参数等，就像调用本地方法一样。

​	Feign是Netflix开发的声明式、模板化的HTTP客户端。可以帮助我们更加便捷优雅地调用HTTP API。在Spring Cloud中，使用Feign非常简单，只需要为远程服务创建一个接口，接口上添加`@FeignClient`注解，便可在该接口中定义远程服务中的方法和其`@RequestMapping`。

​	Spring Cloud使Feign支持了SpringMVC注解，并整合了Ribbon和Eureka。

### Feign的工作原理

​	服务提供方需要引入注册中心的依赖，如Nacos。并将提供的服务注册在注册中心。

​	服务消费者同样也需要在注册中心注册。同时需要在启动类上添加`@EnableFeignClients`。并未远程服务创建接口，并用`@FeignClient`修饰。

​	在为服务启动时，Feign会进行包扫描，对被`@FeignClient`注解修饰的接口，按照注解的规则，创建远程接口的本地JDK Poxy代理实例。并将该实例存储到Spring IoC容器中。

​	当远程接口中的方法被调用时，由Proxy代理实例去完成真正的远程访问，并返回结果。

​	Proxy代理实例，实现了远程调用的接口，能够在内部进行HTTP请求的封装和发送。代理实例能够处理远程HTTP请求的响应，并完成结果的编码，返回给调用者。

### Feign的负载均衡

​	OpenFeign默认将Ribbon作为负载均衡器，直接内置了Ribbon。Ribbon是一个客户端负载均衡器，运行在服务消费者端。

​	Ribbon内置的负载均衡策略：

- RoundRobinRule：轮询策略。如果经过一轮轮询没有找到可用的provider，做多能轮询十次。还未找到返回null。
- RandomRule：随机策略
- RetryRule：重试策略。先按照轮询策略获取，若果是白，在指定时间内重试。
- BestAvailableRule：最可用策略，选择并发量最小的provider。
- AvailabilityFilteringRule：可用过滤算法。过滤处理掉处于熔断状态的server与已经超过连接极限的server，对剩余的进行轮询。

#### 更换负载均衡策略

- 修改配置文件
- 添加一个JavaConfig类，使用`@Configuration`注解，类中新建一个`IRule`接口的实现类对象，注册到Spring IoC容器中。

#### 自定义负载均衡策略

- 自己定义一个`IRule`接口的实现类，重写其中的方法。
- 修改JavaConfig类。如排除某个端口。

#### SpringCloudLoadBalancer

​	Netflix对于Ribbon的维护已经暂停，所以SpringCloud推荐使用自定义的SpringCloudLoadBalancer作为负载均衡器。



## SpringCloudFeign与OpenFeign的区别

​	首先，Feign是SpringCloud的一个组件，用于封装HTTP服务调用，Feign内置了Ribbon作为哭护短负载均衡器。Feign使用的方法是，使用Feign的注解定义接口，调用接口，就可以直接使用注册中心注册的服务。

​	Openfeign实在SpringCloudFeign的基础上支持了SpringMVC的注解，如`@RequestMapping`等。OpenFeign的`@FeignClient`注解可以解析SpringMVC的注解，并通过动态代理的方式产生实现类。



# Redis

## 1. 谈谈你对Redis的理解

### 为什么要引入Redis

​	在项目中一般使用MySQL数据库来存储数据，这在性能方面存在一定弊端。由于数据库的持久化数据是存储在磁盘上的，而磁盘的读写速度较慢，当面对高并发场景时，如抢票、抢购等瞬间访问量较大的场景，需要系统在瞬间完成上千万次的读写操作。此时，数据库无法承受，容易导致数据库系统的瘫痪，最终导致服务器的宕机。

​	为了解决这一问题，可以引入Redis，它是一种基于内存的数据库，是NoSQL，并提供一定的持久化能力。

### Redis是什么

​	Redis(Remote Dictionary Server，远程字典服务)，它是一个基于内存实现的，键值型，非关系数据库。它存在如下特点：

- Redis不经可以将数据完全保存在内存中，还可以通过池畔实现数据的持久化支持。
- Redis支持丰富的数据类型，如String， List， Set，Zset, Hash等数据结构。
- Redis支持主从同步，数据可以从主服务器向任意数量的服务器上同步。有效地保证数据安全性。
- Redis支持多种编程语言，C/C++，Java，Python等。

### 与SQL型数据库的区别

​	Redis没有提供新建数据库的操作，它自带16个数据库([0, 15]，默认使用0库)。同一个数据库中，key是唯一的，键值存储的本质就是使用key来识别value。

​	Redis数据库没有表的概念，因为它是非关系数据库。它通过不同的数据类型来实现存储数据的需求。



## 2. Redis的使用场景

### 1) 缓存

​	Redis基于内存，读写速度快，可以用作缓存来减轻MySQL的压力，提升系统性能。

### 2) 消息队列

​	Redis提供发布/订阅机制，可以通过channel和pattern来向其中的订阅者发送消息。另外，我们还可以利用List来实现一个队列机制。

### 3) Session共享

​	Session保存在服务器的文件中，如果是集群服务，同一个用户的请求可能会落到不同的服务器上，就会导致用户频繁登录。利用Redis保存Session后，无论用户的请求落在哪台机器上，都能够获取相应的Session信息。

> ​	Session为会话控制，是服务器为了保存用户状态而创建的一个特殊对象。简而言之，就是一个对象，用于存储信息。
>
> ​	服务器会为每一个浏览器(客户端)创建一个唯一的Session。这个Session是服务器共享，客户端独享的。
>
> ​	Session的接口类似于Map，里面可以存放多个键值对。key必须是字符串，value必须是对象。
>
> ​	当客户端访问浏览器时，HTTP请求中会携带一个名为`JSESSIONID`的cookie，表示Session的id。是由服务器创建的，并且是唯一的。
>
> ​	如果客户端的请求携带了JSESSIONID的cookie，服务器会判断该id对应的Session是否存在，存在就在响应时携带Session对象。如果不存在，就创建Session，并返回JSESSIONID。
>
> ​	如果客户端的请求没有携带JSESSIONID的cookie，服务器会直接创建一个新的Session，并返回JSESSONID。

### 4) 排行榜

​	利用Redis的SortSet来实现。



## 3. Redis的常见功能

- 数据缓存
- 分布式锁Redisson
- 数据持久化
- 支持事务
- 支持消息队列



## 4. Redis支持的数据类型

​	Redis的数据是以键值对的方式存储的，其value支持以下几种类型：

- String字符串
- Hash：value存储的值可以是多个Hash键值对，如`value = {{field1, value1},...{fieldN, valueN}}`
- List：用来存储多个有序的元素，列表两端都可以插入和弹出。可以充当栈和队列的角色。
- Set：相比于List，Set是不允许有重复的元素，但是，Set中的元素是无序的。
- zset：有序集合。不同于List中按照索引排序，可以为每个元素设置一个分数，作为排序依据。





