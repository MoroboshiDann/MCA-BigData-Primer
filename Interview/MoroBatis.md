# 1. Mybatis框架对于JDBC有什么好处，有什么缺点

## 对比JDBC的缺点

- 传统JDBC需要频繁创建和释放数据库连接对象，容易造成资源浪费，影响系统性能。Mybatis中通过数据库连接池来管理数据库连接，避免了手动的创建和释放连接。
- 使用JDBC时SQL语句定义、参数设置和返回结果处理都是以硬编码的方式存在于程序中的，但是SQL语句经常容易发生变化，一旦变化就需要修改程序，不方便维护。
- 结果集处理存在重复代码，而Mybatis可以自动将SQL执行结果映射到Java对象。

## Mybatis的优缺点

优点：
- 基于SQL语句来编程，不用修改程序或数据库。
- SQL语句存储在XML文件中，与程序代码解耦，便于管理和维护。
- 提供XML标签来编写动态SQL，代码重用性高，相较于JDBC可以大大减少代码量。
- 提供字段映射标签，支持Java对象与数据库字段的映射关系。
  

缺点：
- SQL语句编程量大，需要开发人员对SQL语句有一定功底。
- SQL语句依赖数据库，导致数据库移植性差，不能随意更换数据库。

# 2. Mybatis这类ORM框架有什么优点

ORM(Object Relational Mapping)对象关系映射框架，是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。能够通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。

优点：
- 开发效率高。
- 数据访问更抽象、轻便。可以直接调用Dao接口中定义的方法来访问数据库。不需要手动操作具体过程，返回结果也无需手动处理。

缺点：
- 程序执行效率差。大量使用反射，而通过反射编程，编译器无法对其进行优化。
- 难以实现较为复杂的查询，即使可以实现也需要花费很大代价。

# 3. Mybatis如何防止SQL注入

1. 首先，`#{}`将传入的参数转换为字符串，会自动给两端加上`""`，一定程度上可以防止SQL注入。因此，应该尽量使用参数化的SQL语句，而不是直接将参数写到SQL语句中。
2. 使用动态SQL标签，`<if>, <where>, <when>, <otherwise>`等可以根据条件动态生成SQL语句。
3. 限制参数类型，解析SQL语句时会记录其参数的类型，使用时检查参数是否为指定类型。
4. 使用Mybatis Plugin来进行安全检查。Mybatis允许自定义拦截器Interceptor来在程序指定位置进行自定义操作。我们可以定义拦截器，在执行SQL之前进行安全检查。

# 4. Mybaits中#和$的区别

- #将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。
  - 如：`where username=#{username}`，如果传入的值是`111`，那么解析成sql时的值为`where username="111"`，如果传入的值是id，则解析成的sql为where `username="id"`。
- $将传入的数据直接显示生成在sql中。
  - 如：`where username=${username}`，如果传入的值是`111`，那么解析成sql时的值为`where username=111`；如果传入的值是`;drop table user;`，则解析成的sql为：`select id, username, password, role from user where username=;drop table user;`。

通过观察不难发现，#可以很大程度地防止SQL注入，$无法防止SQL注入。

在MyBatis中，`${xxx}`这样格式的参数会直接参与SQL编译，从而不能避免注入攻击。但涉及到动态表名和列名时，只能使用`${xxx}`这样的参数格式。所以，这样的参数需要我们在代码中手工进行处理来防止注入。

# 5. 数据源池化和非池化有什么区别，Mybatis是怎么实现的

非池化的数据源，每次用户申请获取连接时，都会创建一个新的连接对象返回给用户，当用户使用完毕后就会直接关闭。池化数据源会维护一个连接池，每次用户申请连接时就从连接池中去除空闲连接交给用户，用户使用完毕，数据源会根据空闲连接的情况来决定是将连接释放还是放回连接池。

Mybatis中既有池化数据源的实现也有非池化数据源的实现。具体使用什么类型的数据源，则是根据配置XML中的`<dataSource>`标签来决定。

Mybatis中池化数据源在池化数据源的基础上进行的扩展。首先，数据源获取的连接对象都是通过`DriverManager#getConnection`方法来得到的，但是这是Java自己的实现连接实现类，当执行到`close()`方法时就会将连接关闭，而为了能够根据连接池的情况来决定是否释放，就需要通过Java动态代理的方式为Connection接口生成代理对象，这样就能在关闭连接时，执行自己的逻辑。于是Mybatis就用PooledConnection类来管理真实的Connection对象和自己生成的代理对象的绑定关系。

当用户申请连接时，就将代理对象返回给用户，用户使用完毕执行`close()`方法，代理对象就会调用数据源的`pushConnection()`逻辑，来判读代理对象对应的真实数据库连接是否要释放。如果不释放，就将当前代理对象置为无效，并重新生成代理加入连接池。

# 框架中的反射和代理怎么体现的

## 代理

首先，MyBatis框架可以让我们只给出Dao接口，而不用给出实现类就可以直接调用接口中的方法来操作数据库，这一点就是通过反射和代理来实现的。

通过Java提供的动态代理方式，我们可以实现一个MapperProxy类，实现InvocationHandler接口，重写invoke方法，在其中实现Dao接口方法的执行逻辑。然后，再通过Proxy#newInstance方法，为Dao接口创建代理类对象。这样，在调用Dao接口方法时，实际上是执行的invoke方法中的逻辑，然后在其中我们听过反射的方式来判断方法对应的SQL类型，执行对应的方法。

其次，还有返回结果。比如通过查询语句会将数据库对应记录返回给Java程序，此时我们就需要进行类型映射，创建对应的Java对象，并通过反射的方式将记录中的字段填充到对象对应的属性中去。

# 多边服务如何设计

MyBatis中一次数据库操作，涉及多个步骤，如判断SQL类型、调用SQL执行逻辑、准备SQL语句、参数填充、结果转换等。我们需要按照功能来将一次数据库操作划分开来，将代码解耦。于是就需要定义执行器、语言驱动、语句管理器、参数管理器等，而这些部分之间相互关联调用。我们将他们全部封装起来，外界只需要通过SqlSession来调用即可，而不需要关注内部的细节。

# 设计模式

创建型的：
- 工厂模式：SqlSessionFactory，通过工厂来创建对象，规范操作。
- 建造者模式：可以比较方便地创建对象并填充属性，链式调用。
- 单例模式：Configuration，整个程序只有一个Configuration对象，只有在解析XML文件时才会创建，因此能够保证单例。

结构型的：
- 适配器模式：如日志的适配器，现有的日志框架有很多，为了能够适配使用大部分框架，Mybatis定义了在其内部日志需要完成的动作，抽取到一个接口中，只需要对不同的日志框架给出实现类，即可直接使用该日志框架，而不需要作出修改。
- 代理模式：能够通过对象的替代品来控制程序对于原对象的访问，代理模式也是很多框架的核心，没有代理模式就没有各类框架。
- 装饰器模式：可以将对象封装进包含一些额外行为的封装对象中，从而为元对象绑定新的行为。对于Mybatis中的执行器，我们将大部分逻辑和一级缓存功能放在了SipmpleExcutor中，二级缓存又是在一级缓存的基础上实现的，所以系统会默认创建SimpleExcutor对象，然后判断是否开启二级缓存，如果是就将其在封装进一个二级缓存执行器中。

行为型：
- 模板模式：将代码中的共性逻辑抽取出来，放在一个抽象基类中，子类只需要继承抽象类并重写需要特殊处理的逻辑即可实现不同功能。于是赋予了子类在不改变现有代码的情况下，改变执行逻辑。
  - 例如Mybatis中执行器接口的实现类有很多共性逻辑，只有一小部分是需要根据传入参数特殊处理的，就可以将共性逻辑抽取到一个抽象类中，这样可以节约代码。且子类可以在不修改代码的情况下，改变具体的执行逻辑。

- 策略模式：比如对于返回值的处理，需要按照不同类型来获取不同的值，我们只需要定义一个接口，针对不同类型给出不同实现类，就可以避免大量判断。
  - 策略模式有三种角色，抽象策略接口、具体策略实现类、环境类。环境类将策略实现类对象封装为成员属性。根据外部环境来修改内部成员属性具体的引用实例。可以减少代码中if else。
  - 例如，Mybatis中在解析SQL语句时，就将语句中对应位置的参数类型和其对应的TypeHandler实现类绑定。执行SQL语句传入参数时，会根据参数的不同来调用不同的实现类中的传参方法。但代码中只需要调用`TypeHandler#setParameter`即可。


# 缓存怎么实现的

一级缓存的生命周期是一个Session中，如果一个Session中发起了多次查询操作，就可以在其内部设定一个HashMap，用来缓存查询结果，Session关闭就清空缓存。如果，Session中发生了更新删除等修改操作，就需要清空缓存。

二级缓存的生命周期是是全局的，因为不同的Session也可能会操作同一个SQL语句，所以可以设置一个全局的缓存来减少查询量。当一次会话结束时，可以将一级缓存的内容刷新进二级缓存。这样下次执行相同SQL时就可以读取缓存。也可以为二级缓存设置缓存策略，如先进先出、LRU等。

# Mybatis Plugin怎么实现的

主要是通过Java的代理和拦截器来实现。我们定义拦截器接口和拦截器注解，注解用于标记触发拦截器的位置。然后，通过定义Plugin类来定义插件的具体功能，并通过代理来为拦截器创建代理对象。这样，在执行到对应位置时，会触发拦截器，执行代理对象中对应的逻辑。