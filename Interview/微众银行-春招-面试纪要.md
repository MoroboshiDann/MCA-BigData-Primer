# 2024.4.12 微众银行一面

## 自我介绍

## 有没有参加过实习

我：

​	还没有机会参加实习。

## 毕设方向

我：

​	我毕设的方向是推荐系统。推荐系统就是给定一些用户的历史记录，就是用户和他所选择商品之间的记录，然后通过神经网络去学习其中的信息，抽取用户兴趣，然后将其可能感兴趣的商品推荐给他。我的题目是序列化推荐，在这个领域，可以将用户的历史交互记录看作是一个序列，比如在某个时刻选择了一支笔，然后下一个时刻选择了一支钢笔，然后通过学习这个历史交互序列，推测出用户在当前时刻会选择的商品，推荐给他。

面试官：

​	就你刚刚举的例子里面，我先选择了一支铅笔，然后下一次选择了一个钢笔，你的模型就能够预测出我下一时刻会选择的商品吗

我：

​	如果只是这种情况的话，肯定是不行的，因为给的数据量太少了，这就是推荐系统的冷启动问题。用户刚开始加入系统，他的信息是很少的，其实是不能很准确的学习出他的喜好的。在这种个情况下，推荐效果就很差。

面试官：

​	我目前带的业务组的研究方向就是类似于推荐系统的，学习用户的投资画像，然后给他们推荐金融产品。目前使用的是transformer结构，但是效果不是很理想，可能是因为有效的数据不是很多，所以喂不出来比较好的模型。

## 有没有刷过算法题？ACM经历呢？

我：

​	有刷过算法题，但是不够多，ACM还没机会参加。

面试官：

​	那你就尝试一下这个题：

### 给出50w条数据，从中找到满足A, B, C, D四个条件的1000条数据，请设计算法

### 如果找出前50组数据，每组1000条，算法又该如何设计

## Spring源码读过没有，介绍下AOP的源码

我：

​	度过Spring的源码。AOP是一种思想，面向切面编程，它的底层是Java中的反射，实现是通过动态代理的方式来实现的。比如说，Spring中的`@Component`注解，他会将类或者方法的返回值注册到Spring的IoC容器中，成为一个Spring Bean。它的原理就是，在Spring启动时，扫描指定的包，然后将该注解修饰的类一个实例化对象或方法的返回值，存储到IoC容器里。那这个注解肯定是有一个对应的切面，Spring在这个切面前后进行了上述的操作。

面试官：

​	我自己是先工作，然后才学的Spring，所以觉得Spring的源码写的很好，很多问题都可以通过查源码的方式直接解决，不像之前只能通过百度的方式解决。所以，读源码的这种做法以后也可以保持。

## 怎么理解分布式框架

我：

​	分布式框架，我的理解就是，传统的单体架构，比如Java Web项目，它的服务，比如所有的controller都在同一台服务器上，那一台服务器就要承载所有的请求流量。那在高并发的场景下，一台服务器是很难承受这种压力的，于是我们可以转到分布式架构，进行服务划分。比如，我做的那个网约车项目，我就是把和用户交互相关的接口分成了平台管理端、司机端和客户端三个微服务，让他们分别运行在不同的服务器上，从而降低单个服务器的压力。当然，在高并发情况下，比如乘客数量很多，那也可以同时上线多个乘客端服务，提高服务的承载能力。

​	然后，从单体到微服务，多了这么多服务模块，他们之间要相互调用，想要维护它们之间的调用关系，直接在代码里写死肯定是不现实的，所以，就要引入注册中心。每个服务启动的时候，都要向注册中心注册成一个服务实例，并且每隔一段时间还要告诉注册中心，本服务还存在没有挂掉。这样，当一个服务想要调用另一个服务时，就可以直接从注册中心拉取服务列表，而不用预先写死在本地代码中。

​	至于服务之间的调用，我在项目里使用的是Feign，它整合了Ribbon和Eureka(当时没想起来名字)，可以通过注解的方式，让我们在服务内部像调用本地方法一样去调用远程服务。它本质上就是帮我们封装HTTP请求。

​	当然，我自己也手写过一个RPC框架。在这里进行微服务远程调用时，我就直接使用Spring提供的RestTemplate来手动封装请求路径，就没有Feign那么便捷了。

面试官：

​	对分布式了解的还挺透彻的。

## 分布式锁了解过没有

我：

​	我了解过，在我的项目里也使用了分布式锁，但是是比较简单的实现。我直接使用了Redis的特性，Redis在插入键值对的时候，有一个NX参数，就是只有这个key不存在，才能插入，否则插入失败。通过这样的方式，让分布式线程之间只能有一个线程插入成功，其他的会被阻塞。

​	不过，这样做会有弊端，如一个线程加锁成功，但是他自己挂掉了，那就会出现死锁现象，因为他无法释放锁。关于这一点，我还了解了红锁，虽然还没写到项目里。红锁就是用在Redis也是集群实现的场景下，一个服务想要加锁，就需要依次向所有的Redis节点申请加锁，只有超过半数的Redis节点返回加锁成功，该服务才算加锁成功。这样就避免了上述情况。

## 什么是拦截器？和过滤器有什么区别

我：

​	拦截器了解过，我在项目里也用了。拦截器就是用来做权限控制，比如用户在没有登录之前，不允许访问网站内容；或者，用户是以乘客身份登录的，那肯定不能允许查看司机端的内容。那具体做法就是，在程序里面设置一个拦截路径，一般都是一个String数组，当用户访问其中的路径时，就要拦截一下，检查用户是否登录。

​	过滤器也了解过，它和拦截器原理类似，只是作用的位置更靠前，在请求一到达WebServer的时候就进行拦截。

面试官：

​	那具体原理上的不同有了解过吗？

我：

​	因为用的不多，所以太细节上的都没怎么看。

- 过滤器基于`java.servlet.Filter`实现，它是基于Servlet的，所以依赖Web服务器，只能在Web应用中使用。
- 拦截器是通过Java的反射实现的，可以使用的方位更广。

- 过滤器触发的时间更早，在请求到达Web服务器，发送给DispatcherServlet之前就会进行过滤
- 拦截器是在Servlet调用具体的Handler之前才会触发。

- 假设设置一个过滤器和一个拦截器，对请求进行拦截，该请求如果既有对controller的请求，又有对静态资源的请求。Filter就会拦截两次，因为他会对所有进入Web服务器的请求进行拦截。
- interceptor只会对controller请求进行过滤，这是因为拦截器是在Servlet匹配到对应的Handler之后，在对其进行调用之前才会执行拦截器的逻辑。

## 有没有接触过流量控制？(最后说告知是滑动窗口那种流量控制)

我：

​	流量控制的话，项目里面可能唯一相关的就是，我为了解决Redis缓存穿透问题，给Redis前面加了一个布隆过滤器。缓存穿透就是请求Redis的key是不存在于Redis中的，那请求就一定会到达MySQL数据库。如果有人恶意去使用大量的这样的key去访问Redis，就会对MySQL造成很大的访问流量压力。为了控制流量，就加了个布隆过滤器。原理就是，如果一个key不存在于布隆过滤器中，那肯定也不存在于Redis中，如果key存在于布隆过滤器中，那么大概率也存在于Redis中，不过也存在误判情况。这样做就能控制流量，减少访问数据库的恶意流量。

面试官：

​	这也是一方面，我们在现实业务中常常会用滑动窗口相关的流量控制。根据网络带宽的情况改变窗口大小。。。。(后面都忘了)

## 分布式事务是什么

我：

​	还没了解到。

## 网约车项目里面，用户下单后周围如果有很多司机，怎么完成抢单的动作？

我：

​	在我这个项目里面，我用的是定时任务，初始时在上车地址半径为2公里的范围内搜索合适的车辆，如果搜索不到就每过20秒增大搜索半径。在找到的候选车辆列表里面，再去筛查司机是否是正常出车状态，等等条件，都满足了才会将订单派给司机。所以，其实是服务器在做判断，不是司机主动在抢单。

## 在项目里面经常会遇到业务原则与技术原则相冲突的情况，如何权衡呢

我：

​	因为我还没有参加过工作，所以了解的也不多，但是从我的认知出发的话，我觉得可以从成本方面去权衡。比如一个服务从业务原则上应该划分为两个微服务，但是从技术原则上看，它们两个之间又调用频繁，就可以考虑通信成本和硬件成本，决定是否将微服务合并。

面试官：

​	确实可以从这方面考虑。

## 你的项目有没有进行过压力测试，测测并发量

我：

​	还没来得及进行测试。

## 反问环节，我提问前段时间飞书从微服务迁移向单体架构，所以对比单体架构，微服务的优势不明显吗，未来微服务还能走下去吗？

​	面试官：我们微众银行在可预见的未来都会坚持微服务架构，因为设计之初就是微服务的思想。银行领域，只有大银行如招行，建行这种体量的才玩得起单体机，每三年硬件维护成本就在10位数。目前微众银行维护一个可乎树的成本是2元，建行的单体架构一个客户成本是500元，招行是700元，所以微服务还是为微众银行解决了很多实际问题的，未来还是会是微服务架构。