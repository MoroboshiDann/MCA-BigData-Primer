# 一、基本概念与常识

## 1. Java语言的特点

- 简单易学，好上手。
- 面向对象(封装、继承、多态)。
- 平台无关性(Java程序编译为平台无关的字节码文件，在对应平台上的JVM上皆可直接运行)。
- 支持多线程(C++没有内置的多线程机制，因此必须调用系统的多线程功能来支持多线程，而Java提供了多线程机制)。
- 可靠性(Java具备异常处理机制和自动内存管理)。
- 编译与解释并存(首先，Java程序会先编译成字节码，然后由JVM逐行解释为机器码交给CPU执行；其次，Java存在JIT可以将字节码直接编译为本地机器码来直接运行)。

## 2. Java SE vs Java EE

Java SE是指Java标准版，Java语言的基础，包含了Java应用程序开发和运行的核心类库以及虚拟机等核心组件。

Java EE是指Java企业版，在Java SE的基础上，增加了企业级应用开发和部署的标准和规范，包括Servlet、JDBC、JSP等。


## 3. JVM vs JDK vs JRE

简单来说，JDK包含了JRE，JRE又包含了JVM。

### JVM

JVM是指Java虚拟机，是负责将Java程序编译好的字节码文件加载入内存并解释执行的程序。JVM针对不同的操作系统都有不同的实现，目的就是为了能够让一个Java程序经过一次编译生成的字节码能够在不同平台上直接运行，而不用作出修改。

另外，JVM并不是只有一种，只要是符合Java虚拟机规范，每个公司都可以实现自己的JVM。

### JDK & JRE

JRE是指Java运行时环境，它包含了运行一个已编译Java程序所需的所有内容的集合，其中就包括了JVM和Java基础类库。

JDK是指Java开发工具，是提供给开发者使用的，能够创建和编译Java程序的开发套件。它包含了JRE和其他的工具，如jconsole，jdb，javadoc等。


## 4. 什么是字节码，字节码的优缺点

字节码即`.class`文件，是Java程序编译后的二进制文件。字节码文件能够被JVM直接运行，它不面向特定的处理器，只面向虚拟机。JVM运行时会将字节码文件加载进内存，并将字节码指令逐个翻译为机器码，交给处理器执行。

优点：
- 首先，就是Java的一次编译到处运行。Java程序只需要经过一次编译，就可以在不同平台上直接运行。
- 一定程度上解决了纯解释型语言的效率低的问题，在Java程序编译为字节码文件时，就可以被编译器优化从而调高解释执行的效率。

缺点：
- 性能相较于纯编译型的语言较差，因为字节码文件还需要经过JVM解释才能运行，因此时间效率上比不过纯编译型语言。
- 存在反编译风险，字节码文件更容易被反编译。
- 启动时间长，JVM需要初始化和加载字节码，因此Java程序的启动时间相较于纯编译型语言稍显劣势。
- Java字节码文件依赖JVM，因此，目标机器上必须安装相应版本的JVM才能正常运行。

## 5. 为什么说Java编译与解释并存

首先，Java程序需要先被编译为二进制字节码文件，这一步就是编译的体现。然后，再通过JVM将字节码指令逐条翻译为机器指令来交给处理器执行，这一步就是解释的体现。因此Java是编译与解释并存。

其次，JVM中存在JIT即时编译器，可以在字节码指令执行时，进行热点代码的探测，然后将热点代码直接编译为本地机器代码交给处理器执行从而提高效率。因此，Java程序在运行过程中既有字节码指令的解释执行，又有编译好的本地代码的直接执行，因此Java编译与解释并存。

## 6. AOT与JIT

### JIT

JIT是指即时编译，JVM在解释执行字节码文件时，会对其中的热点代码进行探测，然后将热点代码编译为本地机器码，从而可以直接在处理器上执行，提高程序的执行效率。

优点：
- 可以根据当前硬件情况实时编译生成最优机器指令。
- 可以根据当前程序的运行情况生成最优的机器指令序列。
- 可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用。

缺点：
- 编译需要占用运行时资源，会导致进程卡顿。
- 需要一定时间和调用频率才能触发JIT。

### AOT

AOT预编译，是相对于JIT来说的，它是在Java程序还没有执行以前，就提前将字节码编译为可以直接执行的机器码。JVM在一起动时就可以直接调用这些预编译好的代码，从而提高启动速度，提高执行效率。同时，JIT需要预热，在执行过程中逐渐地将字节码编译，AOT就可以避免JIT预热的开销。

优点：
- 在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗。
- 可以在程序运行初期就达到最高性能。
- 可以显著的加快程序的启动。

缺点：
- 在程序运行前编译会使程序安装的时间增加。
- 将提前编译的内容保存会占用更多的内存。
- 不能根据程序的运行情况进行调整。


## 7. Java和C++的区别

- Java提供自动内存管理，而C++需要手动分配和释放内存空间。
- Java不提供指针来直接访问内存，程序的内存更加安全。
- Java的类不支持多继承，而接口可以多继承。C++的类可以多继承。
- C++同时支持运算符重载和方法重载，Java只支持方法重载。


# 二、基本数据类型

## 1. 基本数据类型和其包装类型的区别

- 用途：基本数据类型一般只用作常量和局部变量，而包装类型用途较广。
- 存储方式：基本数据类型一般直接存储在Java虚拟机的局部变量表中，而包装类型在局部变量表中只有一个引用变量，其实力本身存储在堆中。
- 占用空间：基本数据类型相较于其对应的包装类型，占用空间较少。
- 基本数据类型可以通过`==`来判断是否相同，而包装类型`==`只能判断引用对象的地址是否相同。

Java中万物皆对象，一些场景下，如泛型，不能使用基本数据类型的数据，因此要用包装类型数据来装箱。另外，Java还提供了自动装箱和拆箱的机制。

## 2. 包装类型的缓存机制

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

Byte，Short，Integer，Long这4种包装类默认创建了数值$[-128，127]$的相应类型的缓存数据，Character创建了数值在$[0,127]$范围的缓存数据，Boolean直接返回True or False。

也就是说，连续两次通过自动装箱机制来申请包装类型数据，会返回同一个对象，前提是数据要落在缓存范围内。(如果使用的是new关键字，一定会创建新的对象)。

## 3. 自动装箱与自动拆箱

- 装箱：将基本类型用它们对应的引用类型包装起来。
- 拆箱：将包装类型转换为基本数据类型。

在遇到需要装箱和拆箱的场景就会触发，如将包装类型赋给基本数据类型的变量。

## 4. 为什么浮点数计算会丧失精度

因为浮点数遵循的是IEEE 754协议，其表示一个数的时候，会通过阶码和尾数来表示一个浮点是，而尾数部分长度有限，当浮点数超出了尾数部分所能表达的精度，超出部分就会丧失。

为了解决，可以通过BigDecimal来对浮点数运算。

## 5. 为什么静态方法不能调用非静态成员

首先，静态方法是被`static`关键字修饰的方法。静态方法是属于类的，当类的`.class`文件被加载进内存时，就会分配内存，不依赖于类的实例化对象，可以直接通过类名来调用。因此，即使当前类没有任何实例对象也是可以直接使用静态方法的。如果此时静态方法内部调用了非静态的成员，就无法正常运行。

## 6. 重载和重写

方法的重载是指使用同一个方法名，不同的形参来定义不同的方法。发生在类的内部。

方法的重写是指子类重写父类中定义的方法，方法名和参数列表都需要相同。

# 三、面向对象基础

## 1. 面向对象和面向过程的区别

- 面向过程会将问题拆解成一个一个的方法，通过方法的调用来解决问题。
- 面向对象则是将问题中涉及到的内容抽象成一个一个的对象，通过对象之间的交互来解决问题。

面向对象更符合思考问题的过程，能够更清晰地描述问题。

## 2. 如果一个类没有声明构造器，能否实例化对象

Java中即使一个类没有显示地定义构造方法，在编译时也会自动补充上一个`public`修饰的空参构造器。因此，可以实例化对象。但是，只要在类中定义了构造器，就不会有默认的空参构造器了，此时如果调用空参构造器就会报错。

构造方法名称必须和类名相同，没有返回值，不能被重写但是能够被重载。

## 3. 面向对象三大特征

- 封装：是指把一个对象的状态信息(也就是属性)隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性getter/setter。
- 继承：不同类型的对象，相互之间经常有一定数量的共同点。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。
  - 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
  - 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
  - 子类可以用自己的方式实现父类的方法。
- 多态：具体表现为父类的引用变量指向子类的实例对象。
  - 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定。
  - 多态不能调用“只在子类存在但在父类不存在”的方法。
  - 如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。

## 4. 接口和抽象类的区别

共同点：
- 都不不能被实例化。
- 都有抽象方法。
- 都可以有默认实现的方法。

不同点：
- 接口主要是对类的行为进行约束，当前类实现了某个接口就具有了某项功能；而抽象类只是为了代码复用和体现继承关系。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员属性只能是`public static final`类型的，而抽象类中的成员属性默认是`default`，可以在子类中重新定义，可以重新赋值。

## 5. 深拷贝和浅拷贝

深浅拷贝对应的场景是类中的成员变量是另一个类的实例对象。此时，如果拷贝类的对象，就会出现深拷贝和浅拷贝。

- 深拷贝：成员对象也会重新实例化一个新的对象，将引用赋给成员变量。
- 浅拷贝：成员对象还是指向原来的对象，即拷贝前后的新老对象，其内部的成员对象指向的是同一个实例化对象。

## 6. ==和equals

- 对于基本类型变量来说，`==`和`equals()`等同，都是判断变量值是否相等。
- 对于引用类型变量来说，`==`只能判断引用的对象在堆内存中的地址是否相同，`equals()`可以经过重写判断属性值是否相同。

上述现象是因为Java中，方法中的变量都是保存在局部变量表中的，使用`==`就是判断局部变量表中存储的内容。但是引用类型变量在局部变量表中存储的内容，是实例对象在堆内存中的地址。因此，使用`==`就只能判断地址是否相同。

而引用类型都是继承自Object类，Object类中提供了`equals()`方法，可以在类中重写，用来判断属性是相同。

## 7. hashCode的作用

`hashCode()`方法是一个本地方法，能够根据指定的属性来计算哈希值。

在一些容器中，如HashMap、HashSet，会先根据哈希值来判断元素是否已经出现在容器中。如果计算出两个对象哈希值相同，再根据`equasl()`方法来判断对象是否相等，可以大大减少判断的耗时。

因此，有如下结论：
- 哈希值不同，两个对象一定不同。
- 哈希值相同，两个对象也可能不相同。
- 哈希值相同，如果`equals()`方法也返回true，就认为两个对象是相同的。

因此，重写`equals()`方法时，也要重写`hashCode()`方法。避免出现`equals()`判断相等，但是哈希值不相等的情况。




