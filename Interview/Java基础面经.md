# 一、基本概念与常识

## 1. Java语言的特点

- 简单易学，好上手。
- 面向对象(封装、继承、多态)。
- 平台无关性(Java程序编译为平台无关的字节码文件，在对应平台上的JVM上皆可直接运行)。
- 支持多线程(C++没有内置的多线程机制，因此必须调用系统的多线程功能来支持多线程，而Java提供了多线程机制)。
- 可靠性(Java具备异常处理机制和自动内存管理)。
- 编译与解释并存(首先，Java程序会先编译成字节码，然后由JVM逐行解释为机器码交给CPU执行；其次，Java存在JIT可以将字节码直接编译为本地机器码来直接运行)。

## 2. Java SE vs Java EE

Java SE是指Java标准版，Java语言的基础，包含了Java应用程序开发和运行的核心类库以及虚拟机等核心组件。

Java EE是指Java企业版，在Java SE的基础上，增加了企业级应用开发和部署的标准和规范，包括Servlet、JDBC、JSP等。


## 3. JVM vs JDK vs JRE

简单来说，JDK包含了JRE，JRE又包含了JVM。

### JVM

JVM是指Java虚拟机，是负责将Java程序编译好的字节码文件加载入内存并解释执行的程序。JVM针对不同的操作系统都有不同的实现，目的就是为了能够让一个Java程序经过一次编译生成的字节码能够在不同平台上直接运行，而不用作出修改。

另外，JVM并不是只有一种，只要是符合Java虚拟机规范，每个公司都可以实现自己的JVM。

### JDK & JRE

JRE是指Java运行时环境，它包含了运行一个已编译Java程序所需的所有内容的集合，其中就包括了JVM和Java基础类库。

JDK是指Java开发工具，是提供给开发者使用的，能够创建和编译Java程序的开发套件。它包含了JRE和其他的工具，如jconsole，jdb，javadoc等。


## 4. 什么是字节码，字节码的优缺点

字节码即`.class`文件，是Java程序编译后的二进制文件。字节码文件能够被JVM直接运行，它不面向特定的处理器，只面向虚拟机。JVM运行时会将字节码文件加载进内存，并将字节码指令逐个翻译为机器码，交给处理器执行。

优点：
- 首先，就是Java的一次编译到处运行。Java程序只需要经过一次编译，就可以在不同平台上直接运行。
- 一定程度上解决了纯解释型语言的效率低的问题，在Java程序编译为字节码文件时，就可以被编译器优化从而调高解释执行的效率。

缺点：
- 性能相较于纯编译型的语言较差，因为字节码文件还需要经过JVM解释才能运行，因此时间效率上比不过纯编译型语言。
- 存在反编译风险，字节码文件更容易被反编译。
- 启动时间长，JVM需要初始化和加载字节码，因此Java程序的启动时间相较于纯编译型语言稍显劣势。
- Java字节码文件依赖JVM，因此，目标机器上必须安装相应版本的JVM才能正常运行。

## 5. 为什么说Java编译与解释并存

首先，Java程序需要先被编译为二进制字节码文件，这一步就是编译的体现。然后，再通过JVM将字节码指令逐条翻译为机器指令来交给处理器执行，这一步就是解释的体现。因此Java是编译与解释并存。

其次，JVM中存在JIT即时编译器，可以在字节码指令执行时，进行热点代码的探测，然后将热点代码直接编译为本地机器代码交给处理器执行从而提高效率。因此，Java程序在运行过程中既有字节码指令的解释执行，又有编译好的本地代码的直接执行，因此Java编译与解释并存。

## 6. AOT与JIT

### JIT

JIT是指即时编译，JVM在解释执行字节码文件时，会对其中的热点代码进行探测，然后将热点代码编译为本地机器码，从而可以直接在处理器上执行，提高程序的执行效率。

优点：
- 可以根据当前硬件情况实时编译生成最优机器指令。
- 可以根据当前程序的运行情况生成最优的机器指令序列。
- 可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用。

缺点：
- 编译需要占用运行时资源，会导致进程卡顿。
- 需要一定时间和调用频率才能触发JIT。

### AOT

AOT预编译，是相对于JIT来说的，它是在Java程序还没有执行以前，就提前将字节码编译为可以直接执行的机器码。JVM在一起动时就可以直接调用这些预编译好的代码，从而提高启动速度，提高执行效率。同时，JIT需要预热，在执行过程中逐渐地将字节码编译，AOT就可以避免JIT预热的开销。

优点：
- 在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗。
- 可以在程序运行初期就达到最高性能。
- 可以显著的加快程序的启动。

缺点：
- 在程序运行前编译会使程序安装的时间增加。
- 将提前编译的内容保存会占用更多的内存。
- 不能根据程序的运行情况进行调整。


## 7. Java和C++的区别

- Java提供自动内存管理，而C++需要手动分配和释放内存空间。
- Java不提供指针来直接访问内存，程序的内存更加安全。
- Java的类不支持多继承，而接口可以多继承。C++的类可以多继承。
- C++同时支持运算符重载和方法重载，Java只支持方法重载。


# 二、基本数据类型

## 1. 基本数据类型和其包装类型的区别

- 用途：基本数据类型一般只用作常量和局部变量，而包装类型用途较广。
- 存储方式：基本数据类型一般直接存储在Java虚拟机的局部变量表中，而包装类型在局部变量表中只有一个引用变量，其实力本身存储在堆中。
- 占用空间：基本数据类型相较于其对应的包装类型，占用空间较少。
- 基本数据类型可以通过`==`来判断是否相同，而包装类型`==`只能判断引用对象的地址是否相同。

Java中万物皆对象，一些场景下，如泛型，不能使用基本数据类型的数据，因此要用包装类型数据来装箱。另外，Java还提供了自动装箱和拆箱的机制。

## 2. 包装类型的缓存机制

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

Byte，Short，Integer，Long这4种包装类默认创建了数值$[-128，127]$的相应类型的缓存数据，Character创建了数值在$[0,127]$范围的缓存数据，Boolean直接返回True or False。

也就是说，连续两次通过自动装箱机制来申请包装类型数据，会返回同一个对象，前提是数据要落在缓存范围内。(如果使用的是new关键字，一定会创建新的对象)。

## 3. 自动装箱与自动拆箱

- 装箱：将基本类型用它们对应的引用类型包装起来。
- 拆箱：将包装类型转换为基本数据类型。

在遇到需要装箱和拆箱的场景就会触发，如将包装类型赋给基本数据类型的变量。

## 4. 为什么浮点数计算会丧失精度

因为浮点数遵循的是IEEE 754协议，其表示一个数的时候，会通过阶码和尾数来表示一个浮点是，而尾数部分长度有限，当浮点数超出了尾数部分所能表达的精度，超出部分就会丧失。

为了解决，可以通过BigDecimal来对浮点数运算。

## 5. 为什么静态方法不能调用非静态成员

首先，静态方法是被`static`关键字修饰的方法。静态方法是属于类的，当类的`.class`文件被加载进内存时，就会分配内存，不依赖于类的实例化对象，可以直接通过类名来调用。因此，即使当前类没有任何实例对象也是可以直接使用静态方法的。如果此时静态方法内部调用了非静态的成员，就无法正常运行。

## 6. 重载和重写

方法的重载是指使用同一个方法名，不同的形参来定义不同的方法。发生在类的内部。

方法的重写是指子类重写父类中定义的方法，方法名和参数列表都需要相同。

# 三、面向对象基础

## 1. 面向对象和面向过程的区别

- 面向过程会将问题拆解成一个一个的方法，通过方法的调用来解决问题。
- 面向对象则是将问题中涉及到的内容抽象成一个一个的对象，通过对象之间的交互来解决问题。

面向对象更符合思考问题的过程，能够更清晰地描述问题。

## 2. 如果一个类没有声明构造器，能否实例化对象

Java中即使一个类没有显示地定义构造方法，在编译时也会自动补充上一个`public`修饰的空参构造器。因此，可以实例化对象。但是，只要在类中定义了构造器，就不会有默认的空参构造器了，此时如果调用空参构造器就会报错。

构造方法名称必须和类名相同，没有返回值，不能被重写但是能够被重载。

## 3. 面向对象三大特征

- 封装：是指把一个对象的状态信息(也就是属性)隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性getter/setter。
- 继承：不同类型的对象，相互之间经常有一定数量的共同点。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。
  - 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
  - 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
  - 子类可以用自己的方式实现父类的方法。
- 多态：具体表现为父类的引用变量指向子类的实例对象。
  - 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定。
  - 多态不能调用“只在子类存在但在父类不存在”的方法。
  - 如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。

## 4. 接口和抽象类的区别

共同点：
- 都不不能被实例化。
- 都有抽象方法。
- 都可以有默认实现的方法。

不同点：
- 接口主要是对类的行为进行约束，当前类实现了某个接口就具有了某项功能；而抽象类只是为了代码复用和体现继承关系。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员属性只能是`public static final`类型的，而抽象类中的成员属性默认是`default`，可以在子类中重新定义，可以重新赋值。

## 5. 深拷贝和浅拷贝

深浅拷贝对应的场景是类中的成员变量是另一个类的实例对象。此时，如果拷贝类的对象，就会出现深拷贝和浅拷贝。

- 深拷贝：成员对象也会重新实例化一个新的对象，将引用赋给成员变量。
- 浅拷贝：成员对象还是指向原来的对象，即拷贝前后的新老对象，其内部的成员对象指向的是同一个实例化对象。

## 6. ==和equals

- 对于基本类型变量来说，`==`和`equals()`等同，都是判断变量值是否相等。
- 对于引用类型变量来说，`==`只能判断引用的对象在堆内存中的地址是否相同，`equals()`可以经过重写判断属性值是否相同。

上述现象是因为Java中，方法中的变量都是保存在局部变量表中的，使用`==`就是判断局部变量表中存储的内容。但是引用类型变量在局部变量表中存储的内容，是实例对象在堆内存中的地址。因此，使用`==`就只能判断地址是否相同。

而引用类型都是继承自Object类，Object类中提供了`equals()`方法，可以在类中重写，用来判断属性是相同。

## 7. hashCode的作用

`hashCode()`方法是一个本地方法，能够根据指定的属性来计算哈希值。

在一些容器中，如HashMap、HashSet，会先根据哈希值来判断元素是否已经出现在容器中。如果计算出两个对象哈希值相同，再根据`equasl()`方法来判断对象是否相等，可以大大减少判断的耗时。

因此，有如下结论：
- 哈希值不同，两个对象一定不同。
- 哈希值相同，两个对象也可能不相同。
- 哈希值相同，如果`equals()`方法也返回true，就认为两个对象是相同的。

因此，重写`equals()`方法时，也要重写`hashCode()`方法。避免出现`equals()`判断相等，但是哈希值不相等的情况。



# 四、String

## 1. String、StringBuilder、StringBuffer

StringBuilder和StringBuffer都继承自`AbstractStringBuilder`抽象类，内部也是使用`char[]`来存储字符串，但是`char[]`没有被`final`修饰，所以是可以改变的。都提供`append()`等方法来修改字符串。

StringBuilder线程不安全，StringBuffer是线程安全的。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。



## 2. String为什么是不可变的

首先，String内部使用的是`private final char[]`字符数组来保存字符串，所以数组的引用一旦赋值就不能修改。

另外，String类也被`final`修饰，所以不能被继承，因而防止了被子类继承而修改。



## 3.  字符串拼接

在Java程序中使用字符串拼接有以下几种情况：

- 参与拼接的字符串都是字面量：`String str = "123" + "456";`，会直接优化为拼接的结果。
- 参与拼接的字符串中有变量：`String str1 = "123"; String str2 = "345" + str2;`。

对于第二种情况，JVM会隐式创建一个StringBuilder，然后调用两次`append()`方法来进行字符串拼接。拼接完成后会调用`toString()`方法返回字符串，然后这个StringBuilder就没丢弃。

在循环中拼接字符串，就会重复创建StringBuilder对象，因此要避免在循环中采用`+`来拼接字符串，而是自己创建一个StringBuilder。



## 4. String#equals

`String#equals`方法重写过，可以判断字符串的内容是否相等。



## 5. 字符串常量池

字符串常量池逻辑上属于元空间，但是实际上存放在堆空间上。

常量池中不会存在重复对象，如果要创建的字符串已经存在，就会直接返回地址而不是创建新的。

如果通过字面量来创建字符串`String str = "123";`会直接在常量池中创建对象。

如果通过`new`关键字来创建对象，则分为两种情况：

- 传入的是一个字面量：`String str = new String("123");`，则等同于两条代码`String s = "123"; String str = new String(s);`。会先尝试在常量池中创建字符串，然后再去堆空间中创建一个字符串对象。
- 传入的是一个字符串变量：直接在堆空间中创建字符串对象。



`intern()`，会尝试在常量池中创建一个当前字符串的对象。如果，创建字符串时直接传入的是字面量，那么常量池中就已经存在该字符串对象，`intern()`方法就不会创建新的对象，而是返回地址。



## 6. String会创建几个对象

### 举例

```java
public static void main(String[] args) {
    String s1 = new String("1");
    s1.intern();
    String s2 = "1";
    sout(s1 == s2); // false
    
    String s3 = new String("1") + new String("1");
    s3.intern();
    String s4 = "11";
    sout(s3 == s4); // true
}
```

首先，`s1 == s2`为false，因为s1对象本身是存储在堆空间中的，即便调用了intern，其本身不会发生变化(况且即便不调用intern，也会在常量池创建“1”)。s2直接指向的是常量池中的字符串对象。

然后，s3首先会创建两个`"1"`对象，然后通过StringBuilder来拼接对象，最后返回的是存储在堆中的s3，且此时字符串常量池中没有"11"字符串。接着执行intern，才将“11”在堆中的地址记录在常量池中。s4直接引用的是常量池中的对象，所以其地址就是s3的地址。

如果交换代码顺序就会出现不同结果。

```java
public static void main(String[] args) {
    String s3 = new String("1") + new String("1");
    String s4 = "11";
    s3.intern();
    sout(s3 == s4); // false
}
```

s3在堆上创建后，此时字符串常量池中只有"1"。然后在常量池中创建“11”。s3执行intern时，直接返回的是s4的地址，因此两个字符串变量地址不相同。

```java
public static void main(String[] args) {
    String s = new String("a") + new String("b");
    String s2 = s.intern(); // 创建了对象
    String s3 = "ab";
    sout(s2 == s3); // true
    sout(s == s3); // false
}
```

```java
public static void main(String[] args) {
    String s = new String("a") + new String("b");
    s.intern(); // 发生了对象创建，地址不一致
    String s2 = "ab";
    sout(s == s2); // false
}
```



### 面试题`new String("abc");`会创建几个对象

1个或2个。使用`new`关键字创建String对象，相当于两个语句`String s = "abc"; String str = new String(s);`。

如果常量池中没有存在该字符串，会先在常量池中创建，然后再在堆中创建。

如果常量池种已经存在该字符串，只会在堆中创建。



### `new String("a") + new String("b")`会创建几个对象

5个或几个。

对于a和b，其创建过程都和上一题一致。然后因为涉及到字符串拼接，会使用StringBuilder对象，然后调用toString()方法。因此，最多创建5个。

> toString只会在对中创建字符串对象，而new会先在常量池中创建，再去堆中创建。
>
> 虽然StringBuilder#toString也是调用的`new`关键字，但是构造器不是同一个。只会在对中创建对象。
