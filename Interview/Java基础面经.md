# 一、基本概念与常识

## 1. Java语言的特点

- 简单易学，好上手。
- 面向对象(封装、继承、多态)。
- 平台无关性(Java程序编译为平台无关的字节码文件，在对应平台上的JVM上皆可直接运行)。
- 支持多线程(C++没有内置的多线程机制，因此必须调用系统的多线程功能来支持多线程，而Java提供了多线程机制)。
- 可靠性(Java具备异常处理机制和自动内存管理)。
- 编译与解释并存(首先，Java程序会先编译成字节码，然后由JVM逐行解释为机器码交给CPU执行；其次，Java存在JIT可以将字节码直接编译为本地机器码来直接运行)。

## 2. Java SE vs Java EE

Java SE是指Java标准版，Java语言的基础，包含了Java应用程序开发和运行的核心类库以及虚拟机等核心组件。

Java EE是指Java企业版，在Java SE的基础上，增加了企业级应用开发和部署的标准和规范，包括Servlet、JDBC、JSP等。


## 3. JVM vs JDK vs JRE

简单来说，JDK包含了JRE，JRE又包含了JVM。

### JVM

JVM是指Java虚拟机，是负责将Java程序编译好的字节码文件加载入内存并解释执行的程序。JVM针对不同的操作系统都有不同的实现，目的就是为了能够让一个Java程序经过一次编译生成的字节码能够在不同平台上直接运行，而不用作出修改。

另外，JVM并不是只有一种，只要是符合Java虚拟机规范，每个公司都可以实现自己的JVM。

### JDK & JRE

JRE是指Java运行时环境，它包含了运行一个已编译Java程序所需的所有内容的集合，其中就包括了JVM和Java基础类库。

JDK是指Java开发工具，是提供给开发者使用的，能够创建和编译Java程序的开发套件。它包含了JRE和其他的工具，如jconsole，jdb，javadoc等。


## 4. 什么是字节码，字节码的优缺点

字节码即`.class`文件，是Java程序编译后的二进制文件。字节码文件能够被JVM直接运行，它不面向特定的处理器，只面向虚拟机。JVM运行时会将字节码文件加载进内存，并将字节码指令逐个翻译为机器码，交给处理器执行。

优点：
- 首先，就是Java的一次编译到处运行。Java程序只需要经过一次编译，就可以在不同平台上直接运行。
- 一定程度上解决了纯解释型语言的效率低的问题，在Java程序编译为字节码文件时，就可以被编译器优化从而调高解释执行的效率。

缺点：
- 性能相较于纯编译型的语言较差，因为字节码文件还需要经过JVM解释才能运行，因此时间效率上比不过纯编译型语言。
- 存在反编译风险，字节码文件更容易被反编译。
- 启动时间长，JVM需要初始化和加载字节码，因此Java程序的启动时间相较于纯编译型语言稍显劣势。
- Java字节码文件依赖JVM，因此，目标机器上必须安装相应版本的JVM才能正常运行。

## 5. 为什么说Java编译与解释并存

首先，Java程序需要先被编译为二进制字节码文件，这一步就是编译的体现。然后，再通过JVM将字节码指令逐条翻译为机器指令来交给处理器执行，这一步就是解释的体现。因此Java是编译与解释并存。

其次，JVM中存在JIT即时编译器，可以在字节码指令执行时，进行热点代码的探测，然后将热点代码直接编译为本地机器代码交给处理器执行从而提高效率。因此，Java程序在运行过程中既有字节码指令的解释执行，又有编译好的本地代码的直接执行，因此Java编译与解释并存。

## 6. AOT与JIT

### JIT

JIT是指即时编译，JVM在解释执行字节码文件时，会对其中的热点代码进行探测，然后将热点代码编译为本地机器码，从而可以直接在处理器上执行，提高程序的执行效率。

优点：
- 可以根据当前硬件情况实时编译生成最优机器指令。
- 可以根据当前程序的运行情况生成最优的机器指令序列。
- 可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用。

缺点：
- 编译需要占用运行时资源，会导致进程卡顿。
- 需要一定时间和调用频率才能触发JIT。

### AOT

AOT预编译，是相对于JIT来说的，它是在Java程序还没有执行以前，就提前将字节码编译为可以直接执行的机器码。JVM在一起动时就可以直接调用这些预编译好的代码，从而提高启动速度，提高执行效率。同时，JIT需要预热，在执行过程中逐渐地将字节码编译，AOT就可以避免JIT预热的开销。

优点：
- 在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗。
- 可以在程序运行初期就达到最高性能。
- 可以显著的加快程序的启动。

缺点：
- 在程序运行前编译会使程序安装的时间增加。
- 将提前编译的内容保存会占用更多的内存。
- 不能根据程序的运行情况进行调整。


## 7. Java和C++的区别

- Java提供自动内存管理，而C++需要手动分配和释放内存空间。
- Java不提供指针来直接访问内存，程序的内存更加安全。
- Java的类不支持多继承，而接口可以多继承。C++的类可以多继承。
- C++同时支持运算符重载和方法重载，Java只支持方法重载。


# 二、基本数据类型

## 1. 基本数据类型和其包装类型的区别

- 用途：基本数据类型一般只用作常量和局部变量，而包装类型用途较广。
- 存储方式：基本数据类型一般直接存储在Java虚拟机的局部变量表中，而包装类型在局部变量表中只有一个引用变量，其实力本身存储在堆中。
- 占用空间：基本数据类型相较于其对应的包装类型，占用空间较少。
- 基本数据类型可以通过`==`来判断是否相同，而包装类型`==`只能判断引用对象的地址是否相同。

Java中万物皆对象，一些场景下，如泛型，不能使用基本数据类型的数据，因此要用包装类型数据来装箱。另外，Java还提供了自动装箱和拆箱的机制。

## 2. 包装类型的缓存机制

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

Byte，Short，Integer，Long这4种包装类默认创建了数值$[-128，127]$的相应类型的缓存数据，Character创建了数值在$[0,127]$范围的缓存数据，Boolean直接返回True or False。

也就是说，连续两次通过自动装箱机制来申请包装类型数据，会返回同一个对象，前提是数据要落在缓存范围内。(如果使用的是new关键字，一定会创建新的对象)。

## 3. 自动装箱与自动拆箱

- 装箱：将基本类型用它们对应的引用类型包装起来。
- 拆箱：将包装类型转换为基本数据类型。

在遇到需要装箱和拆箱的场景就会触发，如将包装类型赋给基本数据类型的变量。

## 4. 为什么浮点数计算会丧失精度

因为浮点数遵循的是IEEE 754协议，其表示一个数的时候，会通过阶码和尾数来表示一个浮点是，而尾数部分长度有限，当浮点数超出了尾数部分所能表达的精度，超出部分就会丧失。

为了解决，可以通过BigDecimal来对浮点数运算。

## 5. 为什么静态方法不能调用非静态成员

首先，静态方法是被`static`关键字修饰的方法。静态方法是属于类的，当类的`.class`文件被加载进内存时，就会分配内存，不依赖于类的实例化对象，可以直接通过类名来调用。因此，即使当前类没有任何实例对象也是可以直接使用静态方法的。如果此时静态方法内部调用了非静态的成员，就无法正常运行。

## 6. 重载和重写

方法的重载是指使用同一个方法名，不同的形参来定义不同的方法。发生在类的内部。

方法的重写是指子类重写父类中定义的方法，方法名和参数列表都需要相同。

# 三、面向对象基础

## 1. 面向对象和面向过程的区别

- 面向过程会将问题拆解成一个一个的方法，通过方法的调用来解决问题。
- 面向对象则是将问题中涉及到的内容抽象成一个一个的对象，通过对象之间的交互来解决问题。

面向对象更符合思考问题的过程，能够更清晰地描述问题。

## 2. 如果一个类没有声明构造器，能否实例化对象

Java中即使一个类没有显示地定义构造方法，在编译时也会自动补充上一个`public`修饰的空参构造器。因此，可以实例化对象。但是，只要在类中定义了构造器，就不会有默认的空参构造器了，此时如果调用空参构造器就会报错。

构造方法名称必须和类名相同，没有返回值，不能被重写但是能够被重载。

## 3. 面向对象三大特征

- 封装：是指把一个对象的状态信息(也就是属性)隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性getter/setter。
- 继承：不同类型的对象，相互之间经常有一定数量的共同点。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。
  - 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
  - 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
  - 子类可以用自己的方式实现父类的方法。
- 多态：具体表现为父类的引用变量指向子类的实例对象。
  - 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定。
  - 多态不能调用“只在子类存在但在父类不存在”的方法。
  - 如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。

## 4. 接口和抽象类的区别

共同点：
- 都不不能被实例化。
- 都有抽象方法。
- 都可以有默认实现的方法。

不同点：
- 接口主要是对类的行为进行约束，当前类实现了某个接口就具有了某项功能；而抽象类只是为了代码复用和体现继承关系。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员属性只能是`public static final`类型的，而抽象类中的成员属性默认是`default`，可以在子类中重新定义，可以重新赋值。

## 5. 深拷贝和浅拷贝

深浅拷贝对应的场景是类中的成员变量是另一个类的实例对象。此时，如果拷贝类的对象，就会出现深拷贝和浅拷贝。

- 深拷贝：成员对象也会重新实例化一个新的对象，将引用赋给成员变量。
- 浅拷贝：成员对象还是指向原来的对象，即拷贝前后的新老对象，其内部的成员对象指向的是同一个实例化对象。

## 6. ==和equals

- 对于基本类型变量来说，`==`和`equals()`等同，都是判断变量值是否相等。
- 对于引用类型变量来说，`==`只能判断引用的对象在堆内存中的地址是否相同，`equals()`可以经过重写判断属性值是否相同。

上述现象是因为Java中，方法中的变量都是保存在局部变量表中的，使用`==`就是判断局部变量表中存储的内容。但是引用类型变量在局部变量表中存储的内容，是实例对象在堆内存中的地址。因此，使用`==`就只能判断地址是否相同。

而引用类型都是继承自Object类，Object类中提供了`equals()`方法，可以在类中重写，用来判断属性是相同。

## 7. hashCode的作用

`hashCode()`方法是一个本地方法，能够根据指定的属性来计算哈希值。

在一些容器中，如HashMap、HashSet，会先根据哈希值来判断元素是否已经出现在容器中。如果计算出两个对象哈希值相同，再根据`equasl()`方法来判断对象是否相等，可以大大减少判断的耗时。

因此，有如下结论：
- 哈希值不同，两个对象一定不同。
- 哈希值相同，两个对象也可能不相同。
- 哈希值相同，如果`equals()`方法也返回true，就认为两个对象是相同的。

因此，重写`equals()`方法时，也要重写`hashCode()`方法。避免出现`equals()`判断相等，但是哈希值不相等的情况。



# 四、String

## 1. String、StringBuilder、StringBuffer

StringBuilder和StringBuffer都继承自`AbstractStringBuilder`抽象类，内部也是使用`char[]`来存储字符串，但是`char[]`没有被`final`修饰，所以是可以改变的。都提供`append()`等方法来修改字符串。

StringBuilder线程不安全，StringBuffer是线程安全的。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。



## 2. String为什么是不可变的

首先，String内部使用的是`private final char[]`字符数组来保存字符串，所以数组的引用一旦赋值就不能修改。

另外，String类也被`final`修饰，所以不能被继承，因而防止了被子类继承而修改。



## 3.  字符串拼接

在Java程序中使用字符串拼接有以下几种情况：

- 参与拼接的字符串都是字面量：`String str = "123" + "456";`，会直接优化为拼接的结果。
- 参与拼接的字符串中有变量：`String str1 = "123"; String str2 = "345" + str2;`。

对于第二种情况，JVM会隐式创建一个StringBuilder，然后调用两次`append()`方法来进行字符串拼接。拼接完成后会调用`toString()`方法返回字符串，然后这个StringBuilder就没丢弃。

在循环中拼接字符串，就会重复创建StringBuilder对象，因此要避免在循环中采用`+`来拼接字符串，而是自己创建一个StringBuilder。



## 4. String#equals

`String#equals`方法重写过，可以判断字符串的内容是否相等。



## 5. 字符串常量池

字符串常量池逻辑上属于元空间，但是实际上存放在堆空间上。

常量池中不会存在重复对象，如果要创建的字符串已经存在，就会直接返回地址而不是创建新的。

如果通过字面量来创建字符串`String str = "123";`会直接在常量池中创建对象。

如果通过`new`关键字来创建对象，则分为两种情况：

- 传入的是一个字面量：`String str = new String("123");`，则等同于两条代码`String s = "123"; String str = new String(s);`。会先尝试在常量池中创建字符串，然后再去堆空间中创建一个字符串对象。
- 传入的是一个字符串变量：直接在堆空间中创建字符串对象。



`intern()`，会尝试在常量池中创建一个当前字符串的对象。如果，创建字符串时直接传入的是字面量，那么常量池中就已经存在该字符串对象，`intern()`方法就不会创建新的对象，而是返回地址。



## 6. String会创建几个对象

### 举例

```java
public static void main(String[] args) {
    String s1 = new String("1");
    s1.intern();
    String s2 = "1";
    sout(s1 == s2); // false
    
    String s3 = new String("1") + new String("1");
    s3.intern();
    String s4 = "11";
    sout(s3 == s4); // true
}
```

首先，`s1 == s2`为false，因为s1对象本身是存储在堆空间中的，即便调用了intern，其本身不会发生变化(况且即便不调用intern，也会在常量池创建“1”)。s2直接指向的是常量池中的字符串对象。

然后，s3首先会创建两个`"1"`对象，然后通过StringBuilder来拼接对象，最后返回的是存储在堆中的s3，且此时字符串常量池中没有"11"字符串。接着执行intern，才将“11”在堆中的地址记录在常量池中。s4直接引用的是常量池中的对象，所以其地址就是s3的地址。

如果交换代码顺序就会出现不同结果。

```java
public static void main(String[] args) {
    String s3 = new String("1") + new String("1");
    String s4 = "11";
    s3.intern();
    sout(s3 == s4); // false
}
```

s3在堆上创建后，此时字符串常量池中只有"1"。然后在常量池中创建“11”。s3执行intern时，直接返回的是s4的地址，因此两个字符串变量地址不相同。

```java
public static void main(String[] args) {
    String s = new String("a") + new String("b");
    String s2 = s.intern(); // 创建了对象
    String s3 = "ab";
    sout(s2 == s3); // true
    sout(s == s3); // false
}
```

```java
public static void main(String[] args) {
    String s = new String("a") + new String("b");
    s.intern(); // 发生了对象创建，地址不一致
    String s2 = "ab";
    sout(s == s2); // false
}
```



### 面试题`new String("abc");`会创建几个对象

1个或2个。使用`new`关键字创建String对象，相当于两个语句`String s = "abc"; String str = new String(s);`。

如果常量池中没有存在该字符串，会先在常量池中创建，然后再在堆中创建。

如果常量池种已经存在该字符串，只会在堆中创建。



### `new String("a") + new String("b")`会创建几个对象

5个或几个。

对于a和b，其创建过程都和上一题一致。然后因为涉及到字符串拼接，会使用StringBuilder对象，然后调用toString()方法。因此，最多创建5个。

> toString只会在对中创建字符串对象，而new会先在常量池中创建，再去堆中创建。
>
> 虽然StringBuilder#toString也是调用的`new`关键字，但是构造器不是同一个。只会在对中创建对象。



# 五、异常

**Java 异常类层次结构图概览**：

![](../img/types-of-exceptions-in-java.png)

## 1. Exception和Error的区别

- **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。
- **`Error`**：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获不建议通过`catch`捕获 。例如 Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

## 2. CheckedException和UncheckedException的区别

- 受检查异常：除了RuntimeException及其子类以外，其他的Exception及其子类都是受检查异常。在编译时期，如果没有没有通过`catch`或者`throws`关键字来处理异常，就无法通过编译。
- 不受检查异常：RuntimeException及其子类，只有在运行期间才能发现的异常，编译时期即使不处理也可以通过编译。如空指针异常、数组越界、类型转换错误等。

## 3. try-catch-finally如何使用

- `try`块：用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。
- `catch`块：用于处理 try 捕获到的异常。
- `finally` 块：无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。

**不要在 finally 语句块中使用 return!** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的return返回值会先被暂存在一个本地变量中，当执行到finally语句中的return之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。

## 4. finally中的代码一定会执行吗

不一定，如果在finally之前发生：虚拟机关闭、线程终结、CPU关闭，就不会被执行。



# 六、反射

## 1. 什么是反射，谈谈对反射的理解

反射就是通过类的Class对象来获取类中定义的属性和方法。它赋予了我们在运行时分析类以及执行类中方法的能力。

反射可以让我们的代码更加灵活，为各种框架提供了支持。但是反射也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点。



# 七、序列化和反序列化

## 1. 什么是序列化和反序列化

- 序列化：是指将数据结构或对象转换成二进制字节流的过程。
- 反序列化：是指将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程。

为了能够将Java对象持久化，如保存在文件中，或者通过网络传输对象就需要用到序列化。

## 2. transient关键字

如果对象的某些字段不需要被序列化，就可以通过`transient`关键字来修饰。其作用为：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。

关于 `transient` 还有几点注意：

- `transient` 只能修饰变量，不能修饰类和方法。
- `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
- `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。



# 八、I/O

## 1. 了解Java IO吗

Java的IO是指将数据从外部存储设备输入到内存中，以及从内存中写入到外部存储。Java IO流的类都是从以下四个抽象基类中派生出来的：

- `InputStream/Reader`：所有输入流的基类，前者为字节输入流，后者为字符输入流。
- `OutputStream/Writer`：所有输出流的基类，前者为字节输出流，后者为字符输出流。

## 2. 为什么要分字节流和字符流

**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？**

个人认为主要有两点原因：

- 字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。
- 如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。

## 3. BIO，NIO，AIO

### BIO

同步阻塞IO，应用程序发起read调用后，会一直阻塞，直到内核将待读取数据拷贝到用户空间。

当客户端连接数量较低时，影响不大。但是在连接数量较高的场景下，传统的BIO是无能为力的。

### NIO

非阻塞IO，Java中的NIO可以看作是**IO多路复用模型**。

同步阻塞IO像上面的描述一致，应用程序发起read调用之后会一直阻塞。

同步非阻塞IO，用户发起read调用后，不会阻塞等待，而是可以继续执行其他任务，但是要轮询访问数据是否已经准备完成。轮询检查是比较消耗CPU资源的。

IO多路复用模型：用户线程会先发起`select`调用，询问内核数据是否已经准备好。等待内核准备好数据， 用户线程再发起read调用。read过程中用户线程还是被阻塞。

> 目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。
>
> - **select 调用**：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。
> - **epoll 调用**：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。

**IO多路复用模型通过减少无效的系统调用，减少了CPU资源的消耗。**

Java 中的 NIO ，有一个非常重要的**选择器 ( Selector )** 的概念，也可以被称为 **多路复用器**。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。

### AIO

异步IO，是基于事件和回调机制实现的。用户线程发起read调用后，会直接返回，不会阻塞。当后台处理完成后，操作系统会通知用户线程进行后续的操作。
