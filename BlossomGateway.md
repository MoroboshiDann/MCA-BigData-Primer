参考SpringCloudGateway的实现，不同过滤器一般提供如下的这些功能。

1. **决定路由**：路由过滤器负责确定请求应该被路由到哪个微服务。基于请求的 URL、头信息或其他参数，路由过滤器可以决定合适的服务实例进行处理。
2. **修改请求和响应**：在路由请求到目标服务之前，路由过滤器可以修改请求。这包括添加、删除或修改请求头，改变请求的目的地，或者增加查询参数等。
3. **认证和授权**：虽然通常由专门的过滤器处理，但路由过滤器也可以参与检查用户的认证和授权信息，以决定是否允许请求被路由到下游服务。
4. **负载均衡**：在一个微服务架构中，一个服务可能有多个实例。路由过滤器可以实现负载均衡，确保请求均匀地分布在不同的服务实例上。
5. **容错和重试机制**：路由过滤器可以实现容错机制，比如当目标服务不可用时，自动重试其他实例或提供备用响应。
6. **日志和监控**：在路由请求的过程中，路由过滤器可以记录关于请求的重要信息，这对于监控和分析系统性能至关重要。
7. **处理响应**：在从目标服务接收到响应后，路由过滤器可以对响应进行修改或处理，例如修改响应头、更改响应状态码或者对返回的数据进行转换。
8. **限流和熔断**：在高流量场景中，路由过滤器可以实现限流策略来防止系统过载，或者在后端服务故障时提供熔断机制。

而我的网关项目也将提供这些最基本的过滤器功能。<br />我的网关中包含：鉴权、限流、熔断、负载均衡、Mock、监控、路由七大过滤器。



## 启动过程

1. 读取网关配置。优先级(低->高)：配置文件(resources/gateway.properties)，环境变量，JVM，启动类主函数传入参数。
2. 通过SPI加载配置中心实例，启动配置中心，完成初始化，并给配置中心添加监听器。
3. 实例化容器(容器用来管理Netty的生命周期)，容器的构造方法中初始化Netty服务端、客户端和处理器。
4. 启动容器。`start()`方法中，启动Netty服务端和客户端。
5. 通过SPI实例化注册中心，并初始化。初始化方法中配置注册中心地址、环境，并实例化NamingService和NamingMaintainService。
6. 将网关服务注册到注册中心。并添加监听器。
7. 添加关机任务。



## 请求到达网关后的过程

1. 请求被Netty服务端接收，将通道中的上下文与HTTP请求打包为一个HttpRequestWrapper对象，交给处理器。
2. 处理器将HTTP请求和通道上下文封装为GatewayRequest请求对象，并调用过滤器链工厂，获取过滤器链，将GatewayRequest对象放入，进行过滤校验。
3. 过滤器按顺序执行，最后一个过滤器为路由过滤器，将请求发送至目标服务器。




## Netty

​	负责网关的通信，包括接收请求和转发请求。

​	主要包括三部分：服务端、客户端和处理器。

### 服务端

​	负责接收HTTP请求，接收到之后，执行`channelRead()`方法，从通道中获取HTTP请求对象，并和通道上下文一起，封装为HttpRequestWrapper对象，调用处理器中的`process()`方法，进行处理。

### 客户端

​	封装一个AsyncHttpClient异步HTTP客户端。当发送到网关的请求经过一系列过滤器校验后，封装HTTP请求，转发到对应服务器。

​	异步HTTP客户端，将发送请求的任务封装到一个CompletableFuture对象中，该对象负责发送HTTP请求，等到请求发送完成收到响应后，会异步通知，执行我们设定好的逻辑。

​	我们根据请求的状态，判断是否重发。

### 处理器

​	自定义处理器实现类，实现`NettyProcessor`接口。核心方法为`process()`方法。

#### process

该方法中，先从HttpRequestWrapper中将请求对象和通道上下文取出，然后解析HTTP请求头的相关信息，并将解析出来的信息，如uniqueId独有id、HTTP请求方法、请求发送方IP地址、目标服务器IP、uri等封装为GatewayRequest网关请求对象。

再与服务定义信息一起封装为GatewayContext网关上下文对象。

然后，调用过滤器链工厂获取过滤器链，然后将GatewayContext对象送入过滤器链中，校验。

## 过滤器链

基于策略模式的责任链。

### 认证过滤器

​	第一个过滤器，用来判断请求头中携带的token是否合法。

​	先判断当前请求是否需要鉴权，如果不需要直接放行。然后，从请求头中获取token，然后使用JWT解析token，获取用户id。再去缓存中获取当前id对应的toekn，如果获取不到，证明用户未登录。如果能够获取，在判断两个token是否一致，不一致则鉴权失败。

### 限流过滤器

​	限制一定时间段内，某个服务的某个请求路径的访问次数。

​	基于Redission的RRateLimmiter实现。

### 负载均衡过滤器

通过GatewayContext对象获取当前请求用到的负载均衡规则。然后，根据负载均衡规则从被使用服务的实例集合中获取一个服务实例。然后，将服务实例的IP和端口封装进GatewayRequest对象中。

负载均衡规则有：
- 轮询：定义一个AtomicInteger，每次自增一次，然后从服务实例结合中获取对应实例。
- 随机：生成随机数。
- 权重优先：当前服务中，每个实例都有自己的权重，首先计算存活实例的总权重，然后生成一个[0,total]的随机数randomWeight。遍历实例集合，每次都用randomWeight减去当前服务实例，如果randomWeight小于零，就返回当前实例。


### 路由过滤器

路由过滤器其实要做的就是将我们在经过之前过滤器处理好的请求信息发送出去,去请求具体的后端服务实例。

主要逻辑是使用AsyncHttpClient发送异步请求，我们在之前已经成功的封装好GatewayRequest请求信息，也就是这里的Request，之后我们我们使用AsyncHttpClient来执行这个异步请求，这个异步请求将会返回一个CompletableFuture对象，而我们知道CompletableFuture非常适合于异步任务的场景，这里我们基于CompletableFuture来实现当请求处理完毕之后的收尾工作。



## Hystrix

服务降级：当请求一个服务超时时，直接返回一个托底数据。

熔断：当某一个服务错误率到达阈值时，在一段时间内就不在请求该服务，而是直接返回托底数据。

请求合并：





