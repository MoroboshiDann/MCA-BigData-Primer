# JavaSE初阶

## 初识Java

### 计算机语言的发展历史

计算机语言经过了三代发展

- 第一代：机器语言。直接使用机器码(二进制01串)变成
- 第二代：汇编语言。使用机器指令的助记符来编程
- 第三代：高级语言。语寻程序员使用接近自然语言的指令来编程
  - 面向过程：C，ADA
  - 面向对象：C++，Java，Python

### Java简史

#### 发明目的

SUN公司的Green项目，因为电视盒子这类的电子产品的出现，需要一款小巧紧凑能跨平台(与平台无关)的语言。

要求：语言本身中立，能跨平台

#### 经历阶段

- 2009年，甲骨文(Oracle)公司收购SUN公司
- 2014年推出Java 8

> 目前每半年更新一次Java的版本，但是企业中的主流仍然是7和8。

### Java体系结构

#### JavaSE

Java Standard Edition，标准版，定位在个人计算机上的应用。包括了支持Java应用程序开发和运行的核心类库以及虚拟机等核心组件。

#### JavaEE

Java Enterprise Edition，企业版，定位在五服务器端的应用。是JavaSE的扩展，增加了支持企业级应用开发和部署的标准和规范(Servlet、JSP、EJB、JDBC、JPA、JTA、JMS等)。

#### JavaME

Java Micro Edition，微型版，定位在消费性电子产品的应用上。

> JavaEE包含JavaSE，与JavaME有交集

### Java特性和优势

优势如下：

- 跨平台/可移植性
- 安全性
- 面向对象
- 简单性
- 高性能
- 分布式
- 多线程
- 健壮性

总结：Java很好，在服务端编程和跨平台客户端应用领域很有优势。

### 垃圾收集机制

垃圾收集的目的：清除不再使用的对象。

当对象建立的时候，垃圾收集器就开始监控对象的动态情况，垃圾收集主要是对内存的释放。

- 不再使用的内存空间应被回收

- Java消除了程序员回收无用内存空间的职责，提供一种**系统级线程**跟踪存储空间的分配情况。在JVM空闲时，检查并释放可被释放的内存空间。

- 垃圾收集在Java程序运行过程中自动运行，程序员无法精确控制和干预。
- GC的自动回收，提高了内存空间的利用效率，也提高了编程人员的效率，很大程度上减少了因为没有释放空间而导致的**内存泄漏**。
  - 内存泄漏：申请的空间没有释放，程序也失去了对该空间的访问权，导致空间一直被占用。
  - 内存溢出：申请的空间超出了系统能提供的空间。

> 后续：
>
> - 垃圾收集器的种类
> - 垃圾收集器的底层原理剖析
> - 垃圾收集器的算法与优化

### 跨平台原理

Java是半编译半解释型语言。`.java`源文件经过**编译**，得到`.class`字节码文件，字节码文件便可以在不同平台对应的JVM上进行解释运行。JVM可以将字节码文件翻译为对应平台的机器码。

一次编译，到处运行

> C语言的跨平台原理
>
> `.c`源文件，经过不同平台的编译器，编译为对应平台上可以运行的`.exe`可执行文件
>
> 实际上跨平台是指编译后的文件能否在不同平台上运行，因此C严格来说不是跨平台语言
>
> 不同的平台需要重新编译
>
> 效率对比：C语言效率高，因为`.exe`文件可以直接运行，不需要解释

### 常见DOS命令

常用命令：

- 创建文件夹（ md [盘符:] [路径名] 文件夹名称 ）make directory
- 删除文件夹（ rd [盘符:] [路径名] 文件夹名称 ）remove directory
- 创建文件（ copy con 文件名称.后缀名 ）（ 可以创建，但输入内容的问题还没有解决）
- 查看文件（ type 文件名称.后缀名 ）
- 删除文件（ del 文件名称.后缀名 ）delete
- 拷贝（复制）文件（ copy [源目录或文件] [目的目录或文件] ）

### 编译 执行

从编写到运行的过程：

- 编写`.java`源文件
- 在同目录下打开cmd，使用javac编译该文件，生成`.class`字节码文件
- 使用java运行生成的字节码文件，不需要`.class`后缀

### 常见错误

- 类名与文件名不一致
- 不区分大小写，Java是对大小写敏感的
- 一个文件中可以存在多个类，但是只有一个`public`修饰，且该类必须与源文件名一致
  - 如果一个文件包含了多个类，编译过后会产生独立的`.class`字节码文件，可以独立运行

### API

Application Programming Interface，应用程序编程接口，是一些预先定义好的方法

JDK帮助文档是SUN公司为JDK工具包提供的文档资料，记录了JDK所提供的类的信息

### 反编译工具的使用

反编译，将`.class`字节码文件转换为`.java`源文件

反编译工具：jd-gui.exe

### 扩展面试题

JDK > JRE > JVM

- JDK(Java Development Kit)，是功能齐全的JavaSDK，能够创建和编译Java程序。包含JRE、编译Java源码的编译器javac、文档注释工具javadoc、调试器jdb、可视化监控工具jconsole、反编译器javap
- JRE(Java Runtime Environment)，仅包含 Java 应用程序的运行时环境和必要的类库
- JVM(Java Virtual Machine)，是运行Java字节码的虚拟机，针对不同系统有不同的实现，但是给定相同的字节码可以运行出相同的结果，一次编译随处运行

> JVM并不是只有一种，只要符合JVM规范，每个组织都可以开发自己的JVM



## 数据类型

### 标识符

包、类、变量、方法等的命名就是标识符

定义规则：

- 四个可以：数组、字母、下划线、美元符号

- 两个不可以：不可以以数字开头，不可以使用Java中的关键字
- 见名知意
- 大小写敏感
- 驼峰命名：大驼峰和小驼峰
  - 类名：首字母大写
  - 方法名：首字母小写
  - 包名：不遵循驼峰命名，全部小写

### 关键字

被Java赋予了特殊含义的字符串

### 变量和常量

#### 变量

声明格式，Java是强类型语言，声明变量必须定义类型

```java
type varName [= value, varName [= value]];
```

变量的赋值

- 如果定义了一个变量，而没有给变量赋值，变量相当没有赋值，不会编译进字节码文件
- 如果没有赋值直接使用，会报错

**变量的内存**

- 基础类型变量，变量内存存储的是变量的值
  - 数值型：整数类型，byte，short，int，long；浮点类型，float，double
  - 字符型：char
  - 布尔型：boolean
- 引用类型变量，变量空间存储的是对象所在空间的地址
  - 类
  - 接口
  - 数组

变量作用域

变量起作用的范围，就是离他最近的花括号`{}`。在此范围内都有效，因此内部花括号内也不能重复声明。

局部变量，定义在方法中

成员变量，定义在类中，方法外



##### 整型

进制与范围

- 八进制：`0123`
- 十六进制：`0x123`
- 二进制：`0b101`
- long类型：`123L`。如果数值超出了int的上限，不加L就无法正常赋值给long类型

> 超范围赋值会报错

##### 浮点型

| 类型   | 符号位 | 阶码 | 尾数 | 总位数 |
| ------ | ------ | ---- | ---- | ------ |
| float  | 1      | 8    | 23   | 32     |
| double | 1      | 11   | 52   | 64     |

科学计数法

`double num = 3.14` = `double num = 314E-2`

> 最好不要进行浮点类型的比较，浮点型会丧失精度，甚至存储的数据也是近似相等的

##### 字符型

大小为2B，是按照Unicode码表进行存储的。

> 面试题：`char ch = '2' + 2;`
>
> 输出`ch`结果为：'4'。将'2'对应的数值加2，然后转换为char类型进行存储。

##### 布尔类型

大小为1位，不可以使用0或者非0整数进行赋值。

##### 类型转换

- 自动类型转换：如果转换有损失，就不能通过编译
  - 同一个表达式中有多种类型数据，会进行自动类型转换，自动转换成级别最高的
  - 多种类型数据进行计算，不能有boolean类型参加运算

- 强制类型转换

类型级别：byte, short, char --> int --> long --> float --> double

#### 常量

被final修饰的值被称为**符号常量**。一旦初始化之后，不能更改其值。

如1，2，'a', "abc"等被称为**字面常量**。

字面常量的类型：

- 整型常量 `1`
- 实型常量`1.11`
- 字符常量`'a'`
- 逻辑常量`true`
- 字符串常量`"abc"`

##### 符号常量

字符常量的命名需要全部大写，并用下划线分隔

**扫描器**

```java
Scanner sc = new Scanner(System.in);
sc.nextInt();
sc.nextLine();
```



## 运算符

Java支持如下运算符

- 算术运算符：`+, -, *, /, %, ++, --`
- 赋值运算符：`=`
- 扩展赋值运算符：`+=, -=, *=, /=`
- 关系运算符：`>, <, >=, <=, ==, !=`
- 逻辑运算符：`&&, ||, !, &, |, ^`
  - `&, |`需要把两个操作数都判断完才能确定结果
  - `&&, ||`效率高一些，第一个表达式false或第一个表达式为true就直接返回结果
  - `^`逻辑异或，两个boolean值进行异或
- 位运算符：`&, |, ^, ~, >>, <<, >>>`
  - `>>>`无符号右移
- 条件运算符：`?`，又称三元运算符

优先级：赋值<三目<逻辑<关系<算术<单目



## 流程控制

### 分支结构

#### if else if

#### switch case

```java
switch (value) {
    case 1: sout(1);break;
    case 2: sout(2);break;
    case 3 -> sout(3);
    default: sout("none");break;
}
```

### 循环结构

#### while

#### do while

#### for



## 方法

方法就是一段用来完成特定功能的代码片段

作用是提高代码的复用性

> 面试题：两个数交换是否成功
>
> ```java
> public void swap(int num1, int num2) {
>     int t = num1;
>     num1 = num2;
>     num2 = t;
> }
> public static void main(Stringp[] args) {
>     int a = 10, b = 20;
>     swap(a, b);
> }
> ```
>
> 两个数没有交换成功，因为**Java只能传值**，无论是基本数据类型还是引用数据类型的变量，传入方法时，方法内都会创建一个新的空间，将原变量的值复制一份。
>
> 因此，本例中只是将swap方法中的两个空间的值进行了交换

### 方法的重载

方法的重载是指一个类中可以定义多个方法名相同的，但是参数列表不同的方法。调用时会根据参数自动匹配对应算法。

> 重载本质上是不同的方法，只不过是方法名相同

构成方法重载的条件

- 形参类型不同，形参个数不同，形参顺序不同
  - `void func(int a, double b)`与`void func(doube a, int b)`构成重载
- 只有返回值类型不同无法构成重载
- 只有形参名称不同无法构成重载
- 与修饰符无关



## 数组

### 声明

`int[] arr;`  `int arr[];`

如果数组只声明，没有后续操作，相当于没有创建(不会被编译)。但是赋值为null，还是会在栈空间中开辟空间

### 创建

`int[] arr = new int[10];`

此时，数组才被分配空间，编译器会把声明和赋值合为一句话

使用`new`关键字，会在当前方法的堆空间开辟一块空间，又因为是数组，所以是连续空间，然后将起始地址存储在`arr`标记的栈空间中(即将堆内存地址存储在`arr`变量中)

数组有默认初始值：

- byte[]：0
- short[]：0
- int[]：0
- long[]：0
- float[]：0.0
- double[]：0.0
- char[]：'u\0000'
- boolean[]：false
- 引用数据类型数组：null

### 赋值

如果超出数组长度会出现异常`ArrayIndexOutOfBoundsException`

### 注意

- 数组长度是确定的，一旦被创建大小无法被改变
- 数组元素必须是相同类型的
- 数组类型可以是任意数据类型
- 数组变量属于引用数据类型(数组名对应的变量)，数组也是对象。数组中每个元素相当于该对象的成员变量，因此数组本身是存储在堆中的

### 初始化的方法

- 静态初始化：数组分配空间和赋值同步进行。`int[] arr = {1, 2, 3, 4};`或`int[] arr = new int[]{1, 2, 3};`
  - 注意，第二种写法不能在new后面指定数组长度
- 动态初始化：先声明，后赋值
- 默认初始化：直接new一个出来

### 详解main方法

程序的入口，同一个类中如果有多个成员方法，JVM会自动识别main方法，作为程序的入口。

格式是固定的。程序中可以有多个main方法，但是形参不能相同。

**实参**

- JVM默认情况下传入的是`new String[0]`
- 可以在执行字节码文件时，手动传入参数`java HelloWorld aa bb cc dd`

### 可变参数

允许方法传入数量不固定的参数，参数量可变，解决了方法的重载问题

e.g.

```java
public void exmple(int a, int b, int...nums) {}
```

方法内部对可变参数的处理与数组是一样的

注意：

- 可变参数与其他参数一同传入方法时，只能放在最后一个
- 建议不要使用可变参数

### Arrays工具类

- `static String toString(type[] arr)`
- `static type binarySearch(type[] arr, type target)`：二分查找。只能对有序数组使用才能得到正确结果。
- `static type[] copyOf(type[] original, int newLength)`：复制数组，将原数组复制到一个长度指定的新数组中。新长度可以原数组长度。
- `static type[] copyOfRange(type[] original, int from, int to)`：将指定范围复制到新数组。**包左不包右**
- `static boolean equals(type[] a, type[] b)`：判断两个数组的值是否相等。判断的不是内存地址，而是数组内的元素的值是否相等。
  - 如果使用`a == b`便只能判断两个数组是否在堆空间的内存地址是否一致
- `static void fill(type[] arr, int fromIndex, int toIndex, type val)`：将数组指定位置填充为指定数字。

### 数组的复制

将原数组中指定位置的几个元素，复制到目标数组的指定位置

```java
static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);
```

- src：原数组
- srcPos：原数组开始复制的位置
- dest：目标数组
- destPos：目标数组开始写入的位置
- length：需要复制的长度

```java
System.arraycopy(srcArr, 1, destArr, 3, 3);
```

### 二维数组

定义一个二维数组arr\[a][b]，表示栈中开辟空间命名为arr，存储堆空间的一个数组的内存地址。该数组的每一个元素都存储一个数组的堆空间内存地址。

可以使用arr[a]来访问其中一个一维数组。

- arr.length，表示的是一维数组的个数，即arr所存储的数组长度

```java
for (int i = 0; i < arr.length; i++) {
	for (int num : arr[i]) {
        sout(num);
    }
}
for (int[] a : arr) {
    for (int num : a) {
        sout(num);
    }
}
```

#### 二维数组初始化方式

- 静态初始化：声明和赋值同时进行
  - `int[][] arr = {{1,2}, {1, 2, 3}}`
  - `int[][] arr = new int[][]{{1, 2}, {1, 2, 3}}`
- 动态初始化：声明与赋值分开进行
- 默认初始化：直接按照元素类型进行默认初始化



## 面向对象

### 类和对象

类是对事物的定义，对象是类的实例化。如：人类和一个具体的人之间的关系。

类是抽象的，对象是具体的。

### 面向对象三个阶段

- 面向对象分析OOA：Object Oriented Analysis
- 面向对象设计OOD：Object Oriented Design
- 面向对象编程OOP：Object Oriented Programming

### 创建类

新建类，书写类的代码

### 创建对象

第一次使用`new`关键字创建对象是，会使用`ClassLoader`类提供的`loadClass()`方法来加载类文件创建对象。再次创建类时，就不会再加载类文件了。

**类文件只会被加载一次**

### 局部变量和成员变量

- 代码中位置不同：成员变量在类中方法外，局部变量在方法中或代码块中
- 作用范围不同：成员变量可以在类中的所有方法中访问，局部变量只能在当前方法或代码块中使用
- 是否有默认值：成员变量有默认值，局部变量没有(不赋值直接使用会报错)
- 是否要初始化：成员变量不需要初始化，局部变量需要初始化
- **内存中位置不同**：成员变量在堆内存中，局部变量在栈内存中
  - 成员方法在类被实例化的时候，在堆中开辟内存
  - 局部变量随方法的调用而出现在栈中
- 生命周期不同：成员变量随对象的创建和销毁而存在和消失，局部变量与方法生命周期一致

### 构造器

 使用new关键字创建对象，是通过调用构造器来初始化对象的。如果没有写构造器，系统会默认分配一个构造方法。

调用构造器之前，对象就已经创建好了，成员属性也已经有初始化的值了，调用构造器只是对属性进行赋值

```java
public class Person {
    private int age;
    private String name;
    public Person() {}
    public Persion(String name, int age) {
        this.name = name;
        this.age = age;
    } 
}
```

当形参名字和属性名重复时，会根据就近原则，给最近的属性赋值。因此需要使用`this`指定给成员变量赋值

**构造器的重载**

空参构造和全参构造

> 如果构造器已经重载，此时没有写空参构造，系统也不会分配，因此空参创建对象会报错



### 内存分析(简单)

```java
public class Person {
    private String name;
    private int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public static void main(String[] args) {
        Person person = new Person("bob", 20);
    }
}
```

上述代码执行过程的内存分析

- 首先在*栈*中加载`main`方法的栈帧
- 然后因为是第一次创建Person对象，所以通过`ClassLoader`类将`Person.class`字节码文件加载到*方法区*
- 使用`new`关键字，根据`Person.class`提供的模板，在堆中创建Person对象，然后给成员属性进行默认赋值。并在对象所在空间内使用一个指针记录`Person.class`在方法区的内存地址。将对象地址返回
- 然后调用了`Person(String name, int age)`构造方法，于是在栈中加载`Person()`方法的栈帧
- 然后在栈帧中，依次入栈传入参数的副本。因为`name`属性为String类型，因此第一次遇到`"bob"`字符串，会在方法区中的*常量池*中寻找是否存在，不存在于是创建一个`"bob"`字符串，并将地址返回给Person的形参
- 然后使用栈帧中的局部变量，给`this`所指空间内的成员变量赋值
- `Person()`退栈，局部变量消失。但是`"bob"`有对象在使用，所以保留
- 在main的栈帧中创建局部变量`person`记录堆中对象的地址

### 内存分析(复杂)

```java
public class Person {
    private String name;
    private int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public void setAge(int age) {this.age = age;}
}
pubilc class Test {
    public static void main(String[] args) {
        Test test = new Test();
        int age = 40;
        Person tom = new Person("tom", 10);
        Person jack = new Person("jack", 20);
        test.changeAge(age);
        test.changeTom(tom);
        test.changeJack(jack);
        sout("id:"+jack.id+",age:"+jack.age);
    }
    public void changeAge(int age) {
        age = 3366;
    }
    public void changeTom(Person tom) {
        tom = new Person("bob", 2);
    }
    public void changeJack(Person jack) {
        jack.setAge(66);
    }
}
```

上述代码的内存分析：

- 在栈中加载`main()`的栈帧
- 第一次遇到`Test`于是将`Test.class`字节码文件加载到*方法区*
- 使用`new`关键字，根据其提供的模板在*堆*中创建对象，没有成员变量，直接将字节码文件的内存地址记录在对象空间中。然后将对象地址返回
- 调用了`Test()`构造方法，在栈中加载Test栈帧，又其内部没有操作，直接退栈
- 在main栈帧中创建`test`变量接收了堆中对象的地址
- 然后在main的栈帧中创建`age`局部变量，并赋值
- 第一次遇到`Person`于是将`Person.class`字节码文件加载到方法区
- 使用`new`关键字，根据字节码文件提供的模板创建对象，并对成员变量进行默认赋值，然后将字节码文件的内存地址存储到对象空间中
- 调用了`Person()`全参构造方法，在栈中创建Person栈帧，在栈帧中使用局部变量记录形参，分别入栈。由于`"tom"`字符串是第一次出现，字符串常量区找不到，所以在其中创建一个`"tom"`对象，并将地址返回给局部变量
- 通过`this`获取当前调用对象的地址，分别使用局部变量的值给成员变量赋值。Person退栈
- 在main的栈帧中创建`tom`接收对象的地址
- 直接根据字节码文件创建Person对象，并对成员变量进行默认赋值，然后将字节码文件的内存地址存储到对象空间中
- 调用了`Person()`全参构造方法，在栈中创建Person栈帧，在栈帧中使用局部变量记录形参，分别入栈。由于`"jack"`字符串是第一次出现，字符串常量区找不到，所以在其中创建一个`"jack"`对象，并将地址返回给局部变量
- 通过`this`获取当前调用对象的地址，分别使用局部变量的值给成员变量赋值。Person退栈
- 在main的栈帧中创建`jack`接收对象的地址
- 通过`test`对象的指针找到`Test.class`提供的模板，找到`changeAge()`方法，并在栈中创建栈帧
- 在chageAge栈帧中开辟空间接收传入的`age`的值(值传递)，并将开空间的值修改为`3366`，退栈
- 创建`changeTom`栈帧，并在栈帧中开辟空间使用局部变量存储`tom`对象的地址(即将main中tom的存储内容赋值给栈中的局部变量)
- 创建新的`Person`对象，过程不再赘述，并将对象的对内存地址返回给局部变量`tom`，退栈。新对象和`"bob"`等待被回收，因为已经没有引用指向这两个对象
- 创建`changeJack`栈帧，并使用局部变量接收`jack`对象，通过jack指向的堆内存空间，找到`Person.class`的地址，然后找到`setAge()`方法
- 创建`setAge`栈帧，并创建局部变量接收形参`66`，通过`this`指针找到当前调用对象，并赋值。退栈
- changeJack退栈
- 创建`println`栈帧，并传入字符串，进行打印输出

### this

记录调用当前方法的对象的地址

作用：

- 可以用来修饰属性。`this.age`相当于`person.age`，可以避免引起歧义，直接使用当前调用对象的成员属性
- 可以用来修饰方法，可以在避免调用方法时，出现同名方法
- 可以修饰构造方法，同一个类的构造方法之间可以相互调用，但是使用`this`调用构造方法必须放在第一

### static

#### static修饰属性

static修饰的成员属性是静态属性，为类所有，即所有对象所共有

静态属性存储在方法区中的*静态域*中，在类加载的时候，会将类的静态内容加载到静态域中。因此先于对象存在。静态内容是所有类的对象共享的

可以通过`ClassName.fieldName`来直接访问，也可以通过`对象名.属性名`来访问

应用场景：

某些特定的数据想要在内存中共享，可以将该该属性变为静态属性



#### static修饰方法

注意：

- 静态方法中不能访问非静态属性
  - 因为静态内容随着类的加载而加载，先于对象而存在，而非静态属性随着对象的创建才存在。在非静态属性存在之前已经可以使用静态方法，所以不能访问
- 静态方法中，不能访问非静态方法
  - 理由同上
- 静态方法中，不能使用`this`关键字
  - 因为静态内容可以使用`类名.方法名`来调用，此时并没有对象调用该方法

### 代码块

分类：

- 普通块：限制了局部变量的作用范围
- 构造块：在方法外的代码块。解决了在方法外写代码的问题
- 静态块：只能访问静态属性和静态方法。
  - 静态块是随着类的加载而加载的，会最先被执行，且只被执行一次
  - 一般用于执行一些全局性的初始化操作，如数据库的初始化，创建工厂等

执行顺序：静态块->构造块->构造器->普通块

### 包

作用：

- 为了解决重名问题。包实际上就是目录
- 解决权限问题

创建包

- 包名全部小写
- 中间使用`.`分隔，分隔后就是不同级别的文件夹
- 一般都是公司域名的反写
- 不能使用系统的关键字
- 包声明的位置，非注释代码的第一行`pakage com.moroboshidan.pojo.entity`

导包

为了定位代码中所使用的类

同一个包中的类互相使用不需要导包

### 三大特性

#### 封装

程序设计追求“高内聚，低耦合”
- 高内聚：类的内部数据操作细节，由类自己完成，不允许外界干涉
- 低耦合：仅对外暴露少量的方法用于使用

> 隐藏对象内部属性，只对外公开简单的接口，便于外界调用。从而提高系统的可维护性和可扩展性

封装的好处：提高代码的安全性

#### 继承

继承关系：

父类/基类/超类，子类/派生类。子类和父类在一定合理范围内进行继承

继承的优点：

- 提高了代码的复用性，父类定义的内容，子类可以直接继承得来，不需要重复定义
- 便于代码的扩展
- 是多态的前提

注意：
- 父类的`private`内容，子类也继承过来了
- 一个父类可以有多个子类，但是一个类只能继承一个父类。但是可以间接继承
- 继承具有传递性，所有的类都直接或间接地继承`Object`类

##### 内存分析

```java
public class Student extends Person {}
{
  Student stu = new Student();
  stu.setName("bob");
  stu.setAge(10);
}
```
上述代码的内存分析

- 第一次遇到`Student`类，通过`ClassLoader`将`Student.class`和其父类`Person.class`的字节码文件加载到方法区
- 然后根据模板在堆内存中创建Student对象，并对成员变量进行默认赋值，并将地址返回
- main的栈帧中创建变量`stu`来接收对象的地址
- 通过`stu`找到堆中的对象，然后根据其记录的地址找到字节码文件，调用成员方法

父类中所有的属性和方法都会被继承，方法也不例外

#### 权限修饰符

权限修饰符的作用范围
|修饰符|同一个类|同一个包|子类|所有类|
|---|---|---|---|---|
|private|&#10004||||
|default|&#10004|&#10004|||
|protected|&#10004|&#10004|&#10004||
|public|&#10004|&#10004|&#10004|&#10004|


# JavaSE中阶

# JavaSE高阶


