# 第一章 JVM整体介绍

## JVM简介

### 基本概念

JVM(Java Virtual Machine)，Java虚拟机。是一种跨语言的平台。JVM只关心字节码文件，不只能够解释运行Java字节码文件，只要语言的编译器遵守相关标准，则JVM就可以解释运行其编译产生的字节码文件。

通过JVM可以实现多语言混合编程，各种语言之间的交互不存在任何困难，就像调用自己语言的原生API一样方便，因为他们最终运行在同一个虚拟机上。

### 虚拟机与Java虚拟机

虚拟机，就是一台虚拟的计算机。是一款软件，用来执行一系列虚拟计算机指令，大体上可以分为*系统级虚拟机和程序虚拟机*：

- 系统级虚拟机：完全对物理计算机的仿真。
- 程序虚拟机：专门为执行单个计算机程序而设计。

无论哪种虚拟机，在其上运行的软件都被限制于虚拟机提供的资源中。

Java虚拟机是一台执行Java自己妈的虚拟计算机，拥有独立的运行机制，Java技术的核心就是Java虚拟机。

Java虚拟机就是二进制字节码的运行环境。有如下特点：

- 一次编译，到处运行
- 自动内存管理
- 自动垃圾回收功能

### JVM的位置

![](../img/JVMLocation.png)

JVM运行在操作系统之上。

## JVM的整体结构

![](../img/JVMStructure.png)

以上为HotSpot VM。主要分为三大部分：

- 类装载子系统：负责将字节码文件加载到内存中，生成Class对象
- 运行时数据区：运行时内存分布，灰色部分为线程独享
- 执行引擎：解释器、JIT、GC



## Java代码执行流程

- `.java`文件，经过编译器(编译器前端)，生成`.class`文件的二进制字节码
- `.class`文件被类加载子系统加载至内存，生成`Class`对象
- 执行引擎将二进制字节码翻译为机器指令，交给CPU执行，如果有热点代码，会进行缓存(JIT)



## JVM的生命周期

### 虚拟机的启动

Java虚拟机的启动时通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的。

### 虚拟机的执行

执行一个Java程序时，真正在执行的是一个叫做Java虚拟机的进程。

### 虚拟机的退出

有如下几种退出情况：

- 程序正常执行结束
- 程序在执行中发生了异常或者错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止
- 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作
- JNI(Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况



## JVM发展历程

### Sun Classic VM

世界上第一款商用Java虚拟机，只提供解释器。jdk1.4被淘汰

## Exact VM

Exact Memory Management，准确式内存管理。虚拟机可以知道内存中某个位置的数据具体是什么类型的数据。编译器与解释器混合工作。

## HotSpot VM

JDK8中默认的虚拟机。HotSpot指的是它的热点探测技术：

- 通过计数器找到最具编译价值代码，触发即时编译或栈上替换
- 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡

## JRockit VM

专注于服务器端应用，可以不太关注程序启动速度，因此，内部不包含解释器实现，全部代码都靠即时编译器编译后执行。

世界上最快的JVM。

## IBM J9

有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。







# 第二章 类加载子系统

类加载器的工作原理包含三个阶段：加载阶段、连接阶段和初始化阶段。

- 类加载子系统负责从文件系统或网络中加载`.class`文件，`.class`文件开头有客厅的文件标识。
- ClassLoader只负责`.class`文件的加载，至于其是否可运行，由执行引擎决定。
- 加载的类信息防御一块称为方法区的内存空间。除了类的信息外，方法区中还会存在存放运行时常量池信息，可能还包括字符串字面量和数字常量。

## 加载阶段Loading

- 通过一个类的全限定名获取此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法去这个类的各种数据的访问入口(将类信息存储在方法区)

> 加载`.class`文件的方式：
>
> - 从本地系统中直接加载
> - 从网络获取，如Web Applet
> - 从zip压缩包中读取，为jar，war格式的基础
> - 运行时计算生成，使用最多的是：动态代理技术
> - 由其他文件生成，如：JSP
> - 从专有数据空中提取`.class`文件
> - 从加密文件中获取，典型的防Class文件被反编译的保护措施





## 连接阶段Linking

### 验证Verify

验证的目的在于确保Class文件的字节楼中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。主要包含四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。

### 准备Prepare

为类变量分配内存并设置该类变量的默认初始值，即零值。

- 所有的变量都会被赋予默认值，而不是实际的赋值。
- 这里不包含使用`final`修饰的`static`元素，因为`final`在编译时就会分配内存，准备阶段会显示初始化。

- 不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量时会随着对象一起分配到Java堆中。

### 解析Resolve

将常量池内的符号引用转换为直接引用的过程。事实上，解析操作往往会伴随着JVM在执行完初始化之后完成。

> 如`System.out.println("hello world");`中是通过符号引用了`java.lang.System`类中的方法，在解析阶段，会直接指向该类对象，转换为直接引用。







## 初始化Initialization

初始化阶段就是执行类构造器方法`<clinit>()`的过程。此方法不需要定义，是javac编译器自动收集类中所有静态变量的赋值动作和静态代码块中的语句合并而来。

类构造器方法中指令按照语句在源文件中出现的顺序执行。

```java
public class Test {
    private static int num = 1;
    static {
        num = 10;
        number = 20;
        sout(number); // 会报错，非法前向引用
    }
    private static int number = 10;
    
    public static void main(String[] args) {
        sout(num); // 10
        sout(number); // 10
    }
}
```

> 上述代码中，首先，`number`可以先赋值，再定义，这是因为在准备阶段，会对`number`进行赋零值操作。但是，如果在静态代码块中就直接输出`number`，就会报错。
>
> 然后，在`<clinit>()`方法中，会先对`num`赋值为1，再赋值为10。对`number`先赋值为20，再赋值为10，按照顺序操作。

`<clinit>()`方法不同于类的构造器。类的构造器在虚拟机中为`<init>()`。

> 如果类中不存在*静态变量和静态代码块*，就不会生成`<clinit>()`类构造器方法。
>
> 任何一个类声明之后，都会至少存在一个类的构造方法`<init>()`。

若当前类具有父类，JVM会保证子类的`<clinit>()`执行前，让父类的`<clinit>()`执行完毕。

虚拟机必须保证一个类的`<clinit>()`方法在多线程下被同步加锁。

> 保证一个类只会被加载一次。一个线程加载成功，其他线程都会被阻塞。



## 类加载器的分类

![](../img/ClassLoaderType.png)

图中的四种类加载器是包含关系，不是继承关系。

JVM支持两种类型的类加载器，分别为引导类加载器(Bootstrap ClassLoader)和自定义类加载器(User-Defined ClassLoader)。

只要是直接或间接继承自ClassLoader的类加载器都是自定义类加载器。常见的类加载器只有三个：

- Bootstrap ClassLoader：加载系统核心类库，使用该引导类加载器进行加载。无法直接获取该类加载器。
- Extension ClassLoader：扩展类加载器。
- System ClassLoader：系统类加载器/应用程序类加载器。加载用户自定义类，默认使用系统类加载器进行加载。

```java
public class Test {
public static void main(String[] args) {
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        ClassLoader extensionClassLoader = systemClassLoader.getParent();
        ClassLoader bootstrapClassLoader = extensionClassLoader.getParent(); // null
        // 用户自定义类加载器
        ClassLoader classLoader = Test.class.getClassLoader();
        sout(classLoader.equals(systemClassLoader)); // true
        // 系统核心类的加载器
        // 用户自定义类加载器
        ClassLoader classLoader1 = String.class.getClassLoader(); // null
    }
}
```



### 虚拟机自带的类加载器

#### 启动类加载器 Bootstrap ClassLoader

- 该类加载器使用C/C++实现的，嵌在JVM内部。
- 使用该类加载器来加载Java的核心类库，如`JAVA_HOME/jre/lib/rt.jar`、`resources.jar`或`sun.boot.class.path`下的内容。用于提供Java自身需要的类。
- 不继承自`java.lang.ClassLoader`，没有父加载器。
- 负责加载*扩展类加载器*和*应用程序类加载器*，并且是这两个类加载器的父加载器。
- 出于安全考虑，启动类加载器只加载包名为`java`、`javax`和`sun`开头的类。

#### 扩展类加载器 Extension ClassLoader

- Java语言编写，由`sun.misc.Launcher$ExtClassLoader`实现。
- 派生于ClassLoader类。
- 父加载器为`Bootstrap ClassLoader`启动类加载器。
- 从`java.ext.dirs`系统属性所指定的目录加载类库，或从`JAVA_HOME/jre/lib/ext`子目录下加载类库。如果用户创建的jar包也放在该目录下，也会由该类加载器加载。

#### 系统类加载器/应用程序类加载器 System ClassLoader/AppClassLoader

- Java语言编写，由`sun.misc.Launcher$AppClassLoader`实现。
- 派生于ClassLoader类。
- 父类加载器为`ExtensionClassLoader`扩展类加载器。
- 负责加载环境变量`classpath`或系统属性`java.class.path`指定路径下的类库。
- *该类加载器是程序中默认的类加载器*，一般来说Java应用的类都是由其完成加载。
- 通过`ClassLoader.getSystemClassLoader()`方法可以获取该来加载器实例对象。



### 用户自定义类加载器

Java应用的开发中，类的加载几乎都是上述三种类加载器完成的。必要时，我们也可以自定义类加载器。

为什么需要自定义类加载器：

- 隔离加载类：可以避免不同模块之间jar包冲突。
- 修改类的加载方式：
- 扩展加载源
- 防止源码泄露：可以在生成字节码文件时进行加密，在加载字节码时进行解密。

使用方法：

- 可以通过继承`java.lang.ClassLoader`类的方式，实现自己的类加载器，以满足一些需求。
- 建议将自己的类加载逻辑写在`findClass()`方法中。
- 如果没有特殊需求，可以直接继承`URLClassLoader`类，能够避免自己编写`findClass()`方法，及获取字节码流的方法。



## ClassLoader

ClassLoader是一个抽象类，除了BootstrapClassLoader外，所有的类加载器都继承自它。

常用方法和获取方式：

- `Class.forName("java.lang.String").getClassLoader();`
- `Thread.currentThread().getContextClassLoader();`
- `ClassLoader.getSystemClassLoader();`
- `getParent`：获取父类加载器，注意不是继承的父类，而是前置。



## 双亲委派机制

Java虚拟机对`.class`文件采用的是按需加载的方式。也就是说当需要使用该类时，才会将它的`.class`文件加载到内存生成Class对象。而且加载某个类的`.class`文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。

![](../img/ParentSubmisson.png)

其工作原理如下：

- 当一个类加载器收到了类加载请求，它不会自己先去加载，而是将请求交付给父类加载器去执行。
- 如果父类加载器还存在父类加载器，则进一步向上委派。请求最终会到达启动类加载器。
- 如果父类加载器能够完成请求，就返回成功；如果父类返回失败，则子类会尝试加载。

> 验证：可以在项目目录中创建一个`java.lang`包，并创建一个`String`类，然后new一个String对象。结果会发现，new出来的还是Java自带的`java.lang.String`，而不是我们自己创建的String。
>
> 这是因为通过双亲委派机制，类的加载请求会不断向上委托，String类最终会由Bootstrap ClassLoader来加载，而它只会加载指定目录下的Java核心类库。
>
> 同时，如果在自定义的String类中调用main方法，会报错，说找不到main方法，原因同上。

`rt.jar`包中的SPI接口，其实现类是由第三方提供的`jdbc.jar`，所以，SPI接口为核心类库，实现类是第三方类库。这种情况下就会出现反向委派，接口由启动类加载器加载，实现类的加载委派给Context ClassLoader，线程上下文类加载器来加载。



双亲委派机制的优势：

- 避免类的重复加载
- 保护程序安全，避免核心API被篡改
  - 如上面提到的自定义`java.lang.String`
  - 或者自己创建一个`java.lang.MyTest`类，此时类的包名是`java`，会由启动类加载器来加载，因此会报错，提示不允许访问。防止恶意破坏启动类加载器。



## 沙箱安全机制

上文中提到的自定义`java.lang.String`，如果运行main方法，就会加载Java核心类库中的String类，然后从其中找到main方法。但是，因为Java自带的String没有main方法，就会报错。这就是沙箱安全机制，可以保护核心代码不受恶意侵害。



## 其他

### 区分两个类的方式

在JVM中，区分两个类是否是一个类有两个必要条件：

- 两个类的完整类名必须一致。
- 加载这两个类的类加载器必须一致，必须是同一个实例。

因此，即使是同一个类被同一个JVM所加载，但是只要是加载时使用的类加载器不是同一个实例，那么产生的两个Class对象也是不同的。

Java类加载器这种特性可以简单的总结为**命名空间**。即在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。

JVM必须知道一个类是由启动类加载器加载的，还是由用户类加载器加载的。如果一个类是由用户类加载器加载的，JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用时，JVM需要保证这两个类的类加载器是相同的。



### 类的主动使用与被动使用

Java程序对类的使用分为主动使用和被动使用，主动使用分为七种：

- 创建类的实例
- 调用某个类或接口的静态变量，或对该静态变量赋值
- 调用类的静态方法
- 反射，如`Class.forName("java.lang.String");`
- 初始化一个类的子类
- Java虚拟机启动时被标记为启动类的类
- 动态语言

除了以上七种情况，类的使用都会被看做是被动使用，不会导致类的初始化。



# 第三章 运行时数据区概述及线程

## 概述

![](../img/RuntimeMemory.png)

不同JVM的运行时内存各有同，以上为HotSpot VM的运行时内存，分为：

- 本地方法栈：用来存储C/C++编写的本地的方法(native method)。
- 程序计数器(Program Conter Register)：PC用来记录当前程序下一条指令的地址。
- 虚拟机栈(JVM Stack)：每调用一个方法，压入一个栈帧。
- 堆区(Heap)：包含新生代和老年代。
- 元数据区(Metaspace)：常量池、方法元信息、klass类元信息。
- CodeCache：JIT编译产物。

JVM的运行时数据区，一部分会随着JVM的创建而创建，随着JVM的退出而销毁，即随进程变化。另一部分随着线程的生命周期变化。

本地方法栈、虚拟机栈和程序计数器是每个线程独一份的。方法区(非堆空间)和堆区是线程共享的。

> 每个Java程序只有一个Runtime对象，可以通过它和运行时环境(运行时内存)进行交互。



## 线程

线程是进程的一个运行单元，JVM允许一个进程有多个并行执行的线程。

在HotSpot VM中，每个JVM线程都和一个操作系统本地线程直接映射。当一个Java线程创建好准备运行时，此时一个操作系统的线程也同时创建。Java线程终止后，操作系统线程也会回收。

操作系统负责所有线程的安排调度。会将线程安排到可用的CPU上。一旦本地线程创建好，就会调用Java线程中的`run()`方法。

### 后台线程

如果使用调试工具，可以看到除了Java应用程序自己编写的线程外(调用main方法的线程和main线程自己创建的线程)，后台还有很多线程在执行。这些后台系统线程主要包含以下几个：

- 虚拟机线程：这种线程的操作需要JVM达到安全点才会出现。该线程的执行类型包括"stop-the-world"垃圾回收、线程栈回收、线程挂起以及偏向锁撤销。
- 周期任务线程：这种线程是时间周期事件的体现，如中断。一般用于周期性操作的调度执行。
- GC线程：这种线程对JVM里不同种类的垃圾回收提供支持。
- 编译线程：在运行时将字节码转换为本地代码。
- 信号调度线程：接收信号并发送给JVM，在它内部调用适当的方法进行处理。



# 第四章 程序计数器

## 程序计数器介绍

JVM中的程序计数器，其命名源于CPU中的PC寄存器，在CPU中用于记录下一条指令的地址。JVM中的程序计数器是对物理PC寄存器的抽象模拟。也是存储下一条指令的地址，由执行引擎负责读取下一条指令。

PC是一块很小的内存空间，是运行速度最快的内存空间。每个线程都有自己的PC，即PC为线程私有，生命周期与线程周期保持一致。

任何时刻，一个线程只会有一个方法在执行，也就是所谓的*当前方法*。PC会记录当前方法的JVM指令地址。如果在执行的是native方法，PC内容为未指定值(undefined)。

PC是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个寄存器。字节码解释器就是通过修改PC的内容来获取下一条需要执行的字节码指令。同时，PC也是JVM规范中唯一没有规定任何OOM的区域。



## 常见问题

### 使用PC寄存器存储字节码指令地址有什么用？为什么使用PC寄存器记录当前线程的执行地址呢？

在CPU中，因为CPU需要不停的切换各个线程，当切换回来以后，CPU需要知道从哪里开始执行。JVM的字节码解释同样也是如此，通过PC寄存器来指明下一条需要执行的指令。

### PC寄存器为什么是线程私有

为了能够准确记录每个线程正在执行的字节码指令地址。还是因为会有线程切换。

CPU采取的是时间片轮转，CPU或者多核CPU的每个核心，每个时刻只会执行一个线程的一条指令，总是会频繁的切换线程。



# 第五章 虚拟机栈(栈帧内都包含什么结构)

## 概述

Java的指令是基于栈来实现的，优点是可以跨平台，指令集小，编译器容易实现。缺点是，性能下降，实现同样的功能需要更多指令。

栈是运行时的单位，而堆是存储的单位。即，栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题,即数据怎么放、放在哪儿。

Java虚拟机栈，每个线程创建时都会创建一个虚拟机栈，内部保存一个一个的栈帧，对应每次的方法调用。因此，生命周期和线程一致。保存方法的局部变量、部分结果，并参与方法的调用与返回。

线程调用方法，会压入栈帧；方法执行结束，会弹出栈帧。所以，对于虚拟机栈来说，不存在垃圾回收问题。但是，如果不停的方法调用，会存在栈溢出问题(OOM)。



## 虚拟机栈的常见问题以及如何设置栈大小

如果采用固定大小的Java虚拟机栈，那么每一个线程的Java虚拟机栈容量可以在线程创建时独立选定。如果线程请求分配的容量超过了JVM允许的最大容量，JVM会抛出一个`StackOverflowError`异常。

如果Java虚拟机栈的大小可以动态扩展，那么在尝试扩展时无法申请到足够的内存，或者在创建新线程时没有足够的空间去创建对应的虚拟机栈，JVM就会抛出`OutOfMemoryError`异常。



## 栈的存储单位

### 栈中存储什么

每个线程都有自己的栈，栈中的数据都是以栈帧`Stack Frame`的形式存在的。

当前线程的每个正在执行的方法都会各自对应一个栈帧。

栈帧是一个内存区域，是一个数据集，存储着方法执行过程中的各种数据信息。

### 栈运行原理

JVM直接对Java虚拟机栈的操作只有两个，就是对栈帧的压栈和出栈。遵循先进后出原则。

在一个活动线程中，一个时间点上，只有一个活动的栈帧。即当前只有一个正在执行的方法。这个栈帧被称为当前栈帧(Current Frame)。与当前栈帧对应的方法就是当前方法。定义这个方法的类就是当前类。

执行引擎运行的所有二进制字节码指令只针对当前栈帧进行操作。

如果在当前方法中调用了其他方法，对应的新的栈帧会被压入栈，成为当前栈帧。



需要注意：

- 不同线程的栈帧之间不允许相互引用。
- 如果当前栈帧调用了其他方法，该方法执行结束时，会返回执行结果给调用栈帧。然后JVM会丢弃该方法的栈帧。
- Java方法有两种返回方法的方式，一种是正常方法返回，使用`return`指令；另一种是抛出异常。但是无论哪种，都会抛弃当前栈帧。
  - 如果抛出异常，会将异常返回给调用方法，如果没有处理就要一直向前返回，直到被catch，或JVM停止运行。



### 栈帧内部结构

每个栈帧内部有如下结构：

- 局部变量表(Local Variables)
- 操作数栈(Operand Stack)，或表达式栈
- 动态链接(Dynamic Linking)，或指向运行时常量池的引用
- 方法返回地址(Return Address)，或方法正常退出与异常退出的定义
- 附加信息

## 局部变量表

也被称为局部变量数组或本地变量表。

其定义为一个数字数组，主要用于存储方法参数和定义在方法内部的局部变量。这些数据的类型包括基本数据类型、应用数据类型和`returnAddress`类型。

局部变量表建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题。

局部变量表的容量，是在*编译时期就确定的*，并保存在方法的`Code`属性的`maximum local variables`数据项中。在方法运行期间，是不会改变局部变量表大小的。

方法嵌套调用的次数，由栈的大小决定。栈越大，方法嵌套调用的次数就越多。对于一个方法来说，其参数和局部变量越多，栈帧就越大，占用的空间就越大，进而嵌套调用的次数就越少。

局部变量表中的变量只在当前栈帧有效。方法执行结束，方法的局部变量就会被销毁。

### 关于slot的理解

局部变量表，最基本的单位是slot变量槽。

在局部变量表中，32位以内的数据只占用一个slot，64位的数据(long和double)占用两个slot。

JVM会给每一个slot都分配一个索引，通过索引就可以访问到指定的局部变量。如果需要访问64位的变量，只需要访问前一个索引即可。

当一个实例方法被调用时，其方法参数和方法体内部定义的变量，会按照顺序被复制到局部变量表中的slot上。

> 如果当前栈帧是由构造方法或实例方法创建的，会将调用方法的对象的`this`存储在0号slot上。

局部变量表的slot是可以复用的，如果一个局部变量过了其作用域，其占用的slot就会释放。在其后申请的新的局部变量就有可能复用该slot。这样做可以节省资源。



> 在栈帧中，与性能调优关系最密切的就是局部变量表。在方法执行时，JVM使用局部变量表完成方法的传递。
>
> 局部变量表中的变量也是重要的垃圾回收根节点。只要被局部变量表直接或间接引用的对象，都不会被回收。



### 静态变量与局部变量的对比

Java中变量的初始化顺序为：静态变量初始零值(准备阶段) -> 静态变量显式赋值(初始化阶段) -> 静态代码块赋值 -> 实例变量默认零值 -> 构造代码块赋值 -> 构造函数赋值。

类变量无论是静态的还是非静态的，都会有初始化动作。而局部变量表不存在于系统初始化过程之中，所以，局部变量必须人为初始化，否则无法使用。

> 成员变量一般分为：静态变量(类变量)和非静态变量(实例变量)。





## 操作数栈

每个栈帧内部，还包含一个先进后出的操作数栈，可称之为表达式栈。

在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈/出栈。

- 某些指令将数据压入栈中，区域的字节码将数据取出，使用后再把结果压入栈。
- 如果被执行的方法有返回值，其返回值就会被压入当前栈帧的操作数栈中，并更新PC。
- 操作数栈中的数据类型要与字节码指令的序列严格匹配，由编译器在编译期间验证。同时在类加载过程的类检验阶段的数据流分析阶段要再次验证。
- 我们说Java虚拟机的解释引擎是基于栈的执行引擎。其中的栈就是指操作数栈。

操作数栈，主要用于保存计算中间结果，同时作为计算过程中中间变量的临时存储空间。

操作数栈就是JVM执行引擎的一个工作空间，当一个方法被调用时，会有一个新的栈帧被创建，此时栈帧的操作数栈是空的。

每一个操作数栈都有一个明确的栈深度，在编译时期就已经确定了。

操作数栈中不采用基于索引的数据访问，而是只能通过入栈出栈操作。

### 面试题i++和++i的区别

放在字节码篇章再说。



## 代码追踪



## 栈顶缓存技术

基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但是完成一项操作，需要更多的入栈/出栈操作。内存读写次数也更频繁。于是会拖慢执行速度。

将栈顶元素全部缓存在CPU的寄存器中，以此来降低对内存的读写次数，提高引擎执行效率。



## 动态链接

大部分的字节码在执行时都需要对运行时常量池进行访问。每一个栈帧都有一个指向*运行时常量池*中**该帧所属方法的引用**。这个引用的目的就是为了能够支持当前方法代码的动态链接。

> 方法引用就会变为一个指向常量池中某一行的引用。在常量池该行中，用字符串记录了调用方法的全类名和方法名。但是只是字符串，而不是直接指向该类该方法的引用。

Java源文件被编译为字节码文件时，所有的变量和方法的引用都作为*符号引用*保存在字节码文件的常量池中。比如一个方法中调用了另一个方法，就是通过常量池中指向方法的符号引用来实现的。

动态链接的作用就是将符号引用转为直接引用。

> 符号引用：即用**(用字符串符号的形式)**来表示引用，其实被引用的类、方法或者变量还没有被加载到内存中。
>
> 直接引用：有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中。
>
> 动态链接可以在没有用到该引用时，不加载到内存中。

常量池的作用就是提供一些符号和常量，便于指令的识别。

## 方法的调用：解析与分派

### 方法的绑定机制

JVM中将符号引用转换为被调用方法的直接引用与方法的绑定机制有关。

- 静态链接：当一个字节码被加载进内存时，如果被调用的方法在编译期间可知，且运行期保持不变。这种情况将符号引用转换为直接引用的过程称为静态链接。
- 动态链接：如果被调用的方法，在编译期无法被确定下来，只能够在运行期将符号引用转换为直接引用，这种转换过程具备动态性。称之为动态链接。

对应的绑定机制分为早期绑定和晚期绑定。绑定是指，一个字段、方法、类由符号引用转换为直接引用的过程，仅仅发生一次。

- 早期绑定：在编译期间就转换为直接引用。
- 晚期绑定：在运行期间转换为直接引用。

### 虚方法与非虚方法

非虚方法：编译期就已经确定了具体的调用版本，实现了早期绑定的方法。

- 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。

> 虚方法都涉及到方法的重写，而非虚方法都不能被重写。

JVM中提供如下几种指令来调用方法：

- `invokestatic`：调用静态方法，解析阶段确定唯一方法版本。
- `invokespecial`：调用`<init>()`方法、私有方法、父类方法、解析阶段确定唯一版本。
- `invokevirtual`：调用所有虚方法。
- `invokeinterface`：调用接口方法。

以上四条指令都固化在虚拟机内部，方法的调用执行不可人为干预。

前两条调用的都是非虚方法。其余的除了`final`修饰的方法都是虚方法。

以及一个动态调用指令：

- `invokedynamic`：支持用户指定方法版本。



### invokedynamic

Java本身是静态语言，`invokedynamic`在Java7出现，就是为了支持动态类型语言的支持。

静态语言就是变量本身有类型，只能被赋予特定类型的值；动态语言就是变量本身没有类型，而变量的值有类型。(约等于强类型和弱类型语言)。



### 方法的重写和虚方法表

Java中方法重写的本质：

当调用方法时：

1. 找到操作数栈顶的第一个元素所执行的对象的实际类型,记作C。
2. 如果在类型C中找到，与常量中的描述符、简单名称都相符的方法，则进行访问权限校
    验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回
    `java.lang.IllegalAccessError` 异常。
3. 否则,按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。
4. 如果始终没有找到合适的方法,则抛出` java.lang.AbstractMethodError`异常。

面向对象编程中，会频繁的用到动态分派，如果每次分派都重新在类的方法元数据中搜索合适的目标，会降低执行效率。为了提高性能，Java在类的方法区中建立了一个虚方法表(virtual method table)，使用索引来替代查找。

每个类中都有一个虚方法表，存放着各个方法的实际入口。

虚方法表会在类加载的链接阶段被创建并初始化。类的变量初始值准备完成后，JVM会将该类的虚方法表也初始化完毕。

子类的虚方法会继承父类的虚方法表。并且在父类的虚方法的基础上，添加自己的虚方法。

如果发生法发重写，就会在自己的虚方法表上覆盖父类的虚方法。

## 方法返回地址

在发生方法调用之前，PC寄存器会指向方法调用下一条指令的地址。

方法的返回地址就是保存方法调用时PC寄存器的值。被调用方法执行完毕后，可以跳转到调用点下一条指令。

无论方法以哪种方式退出，都需要跳转。正常退出时，需要跳转至被调用点；异常退出时，调转地址需要通过异常表来确定。

> 程序执行到return指令，就会有返回值返回给调用者。返回的指令有如下几种：
>
> - ireturn：返回值为boolean, bute, short, char, int(32位以下的返回值)
> - lreturn：返回值为long
> - freturn：返回值为float
> - dreturn：返回值为double
> - areturn：返回值为引用类型
> - return：没有返回值。

方法执行过程中遇到了异常，并且这个一场没有在方法中进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。

方法执行过程中抛出异常时的异常处理，存储在一个异常处理表中。

通过异常完成出口的方法，不会给调用者返回值。



## 附加信息



## 面试题

### 举例栈溢出的情况

`StackOverflowError`，通过`-Xss`来设置栈的大小，如果申请的空间超过了这个设定值，就会出现栈溢出异常。

### 调整栈的大小，就能保证不出现溢出吗

不能保证，理论上只能延缓栈溢出出现的时间，不能避免栈溢出。

### 分配的栈内存越大越好吗

不是，如果分配的栈空间过大，可以创建的虚拟机栈就会变小，可能会导致无法创建新的虚拟机栈。出现OOM异常。

### 垃圾回收是否会涉及到虚拟机栈

不会涉及到。

### 方法中定义的局部变量是否线程安全

需要具体问题具体分析。如果局部变量是传入参数，且是引用类型的参数，则有可能存在多个线程操作一个变量的情况，此时线程不安全。

如果是方法内部创建的局部变量，还要分类讨论：如果该变量在方法内部就结束了生命周期，是线程安全的，因为每个线程对应一个虚拟机栈，虚拟机栈之间不会相互影响；如果该变量返回给了调用者，就不是线程安全的。



# 第六章 本地方法接口

本地方法就是Java调用非Java代码的接口。再定义一个本地方法时，并不提供具体实现，而是在Java语言外用其它语言实现。因此，读源码时会发现本地方法用`native`关键字修饰，没有方法体。但是，它并不是没有方法体，只是不是Java实现的。

为什么需要本地方法：Java应用需要与Java外面的环境交互。Java不能直接操作硬件，于是需要借助其他语言来与硬件交互。



# 第七章 本地方法栈

Java虚拟机用于管理Java方法的调用，本地方法栈用于管理本地方法的调用。

本地方法栈也线程私有的。

当某个线程调用一个本地方法时，它就进入到了一个全新的且不受虚拟机限制的世界，它和虚拟机拥有同样的权限。

本地方法可以通过本地方法接口访问虚拟机内部的运行时数据区。

甚至可以直接使用本地处理器中的寄存器(物理寄存器)。

直接从本地内存的堆中分配任意数量的内存。





# 第八章 堆

## 核心概述

堆空间和方法区是进程唯一的，生命周期和进程一致。进程中的所有线程共享堆空间和方法区。堆空间存在如下特点：

- 一个JVM实例只有一个堆内存，堆内存也是Java内存管理的核心区域。
- Java堆空间在JVM启动时就被创建，其空间大小也就确定了。堆空间是Java内存管理最大的一块空间。
  - 堆空间的大小是可以调整的。启动时根据参数调节。
- 《Java虚拟机规范》规定，堆可以处在物理上不连续的空间上。但是逻辑上应该是连续的。
- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer, TLAB)。
- 所有的对象实例和数组都应该在运行时分配在堆上。
  - 几乎所有的对象实例都在这里分配内存。
- 数组和对象实例不会永远都存储在栈上。因为栈帧中保存的只是引用地址，指向的是数组和对象在堆中的位置。
- 方法结束后，栈帧被弹出，但是数组和对象不会马上被回收，仅仅是在GC时才会被移除。
- 堆，是垃圾回收GC的重要区域。

### 堆内存细分

Java8之后，堆空间逻辑上分为三部分：

- 新生代/新生区/年轻代(Young/New Generation Space)
  - 又划分为：Eden区和Survivor区。
  - Survivor区又分为Survivor0和Survivor1。
- 老年代/养老区/老年区(Tenure/Old Generation Space)
- 元空间(Meta Space)：看作是方法区的实现。



## 设置堆内存大小与OOM

### 堆空间大小的设置

通过参数设置堆空间大小，只会影响新生代和老年代的大小。

堆空间的大小可以通过以下两个参数调节：

- `-Xms`：用于设置堆空间的初内存。等价于`-XX:InitialHeapSize`。单位是`byte`。
  - `-Xmx`：用于设置堆区的最大内存。等价于`-XX:MaxHeapSize`。单位是`byte`。

一旦堆空间的内存大小超过了`-Xmx`设置的值，就会抛出`OutOfMemoryError`异常。

通常会将两个参数设置同样的值。其目的是为了能够在垃圾回收后，不需要重新分隔计算堆区的大小，从而提高性能。

默认情况下：初始内存 = 物理内存 / 64；最大内存 = 物理内存 / 4。

> 可以在终端中通过`jps`来查看正在执行的Java进程。然后通过`jstat -gc pid`来查看内存分区。



### OOM的说明与举例

当堆内存已经被填满，但是继续创建对象，就会出现OOM错误。

## 年轻代与老年代

在JVM中的对象可以划分为两类：

- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都很迅速。
- 一类是生命周期较长的对象，极端情况下与JVM的生命周期一致。

年轻代分为Eden、Survivor0和Survivor1。

- 可以通过`-NewRatio`来设置新生代和老年代的比例。默认为2。一般开发都不会调整。	
- 可以通过`-SurvivorRatio`来调整Survivor区和Eden的比例。
- 可以通过`-XX:-UserAdaptiveSizePolicy`，前面有个减号，表示关闭自适应分配策略。

几乎所有的对象都是在Eden区中new出来的。

绝大部分的对象都在新生代中销毁了。



## 图解对象分配过程

### 对象分配过程概述

- new出来的对象，先放在Eden区。
- 当Eden被填满时，程序继续创建对象，JVM的垃圾回收器就会堆Eden进行垃圾回收(Minor GC)。Minor GC会将Eden中不再被其他对象所引用的对象销毁。然后再创建新的对象放在Eden中。
- 接着，会将Eden中剩余的对象放置在Survivor0区。
- 如果再次触发垃圾回收(Eden又被填满了，且又创建了对象)，Survivor0中幸存下来的对象，就会被转移到Survivor1区。
- 此后，每次触发垃圾回收，就会将幸存者区的幸存者转移到另一个幸存者区。
- 每个对象被创建时都会有一个年龄计数器，记录其经历了几次GC。
- 当转移次数达到设定值时，就会被转移到老年代。
  - 可以通过`-XX:MaxTenuringThreshold=<N>`来设置次数，默认是15次。

> 设置老年代的目的就是为了提高性能，如果一个对象的生命周期较长，每次GC都要扫描一遍它，会降低性能。因此，放置在老年代，减少检查的次数。

- 当老年代内存满时，会触发Full GC。对老年代的空间进行垃圾回收。
- 如果老年代执行了GC后，仍然无法进行对象的保存，就会抛出`OutOfMemoryError: Java heap space`。

总结：

- 幸存者s0和s1，谁空谁是to
- 垃圾回收：频繁发生在新生代，很少发生在老年代，几乎不发生在元空间。

### 对象分配的特殊情况

![](../img/newObject.png)

- Minor GC时，如果Eden中存活的对象Survivor区中放不下，也会晋升到老年代中。
- 超大对象如果老年代能够放得下，就会在老年代中创建出来。如果大到老年代都放不下，就会抛出OOM错误。

### 常用调优工具

- JDK命令行
- Jconsole
- VisualVM
- Jprofiler

## Minnor GC、Major GC、Full GC

Minor GC == Young GC。Major GC 和Full GC造成的暂停时间是Minor GC的十倍以上。

JVM进行垃圾回收时，并非每次都对新生代和老年代进行。大部分时间回收的都是新生代。

针对HotSpot VM，它的垃圾回收又可以根据区域的不同，划分为两大类：部分收集(Partial GC)和整堆收集(Full GC)。

- 部分收集：不是完整收集整个Java堆的垃圾，其中又分为：
  - 新生代收集：只是新生代的垃圾收集。
  - 老年代收集：只是老年代的垃圾收集。
    - 目前只有CMS GC才会单独收集老年代。
    - 很多时候Major GC和Full GC混用，需要具体分辨是老年代回收还是整体回收。
  - 混合收集：Mixed GC，收集整个新生代和部分老年代。只有G1 GC才有这种行为。
- 整堆收集：收集整个Java堆的垃圾回收。



Minor GC触发机制：

- 当年轻代空间不足时(单指Eden)，就会触发GC。Survivor满了不会触发，因为每次Eden满了都会整理Survivor。
- 因为Java对象大部分的生命周期都很短，所以Minor GC非常频繁，一般回收速度也很快。
- Minor GC会引发STW(Stop The Work)，暂停其他用户线程，等待垃圾回收结束。



Major GC触发机制：

- 对象从老年代消失时，我们说发生了老年代GC。
- 出现了Major GC，通常会伴随着至少一次Minor GC，但并非是绝对的。在Parallel Scavenge收集器的搜集策略里就有直接进行Major GC的策略选择过程。
  - 也就是说，老年代空间不足时，会先尝试进行Major GC的策略选择过程，从而触发Minor GC。如果之后还是空间不足，会触发Major GC。
- Major GC的速度比Minor GC慢十倍往上，STW时间更长。
- 如果Major GC之后，老年代空间还是不足，就会报OOM。



Full GC触发机制：

- 调用`System.gc()`，系统建议执行Full GC，但是不是必然执行。
- 老年代空间不足
- 方法区空间不足。
- 通过Minor GC后进入老年代的平均大小，大于老年代可用内存。
- 由Eden、Survivor From向Survivor To复制时，对象大小大于To区可用内存，则把该对象转移到老年代。如果此时老年代可用空间不足，就会触发。

说明Full GC是开发时应该尽量避免的，因为暂停时间较长。



## 堆空间分代思想

### 为什么要把Java堆进行分代

经研究，不同的对象生命周期不同，99%的对象是临时对象，生命周期较短。

其实不分代也可以正常运行，分代的唯一理由就是优化GC的性能。如果没有分代，进行垃圾回收时，就需要将所有的对象都扫描一遍。而很多对象都是临时对象，如果分代，可以将新创建的对象放在一起，这样就会腾出很大的空间，同时减少对生命周期较长的对象的重复扫描。



## 内存分配策略

对象晋升(Promotion)规则：

如果对象在Eden被创建出来，并经历过一次Minor GC后仍然存活，如果Survivor To区能够容纳的话，就会被转移到Survivor中。并且将年龄设置为1。对象在Survivor中每经历过一次Minor GC就会增长一岁。当年龄增长到一定阈值时，就会被晋升至老年代。

针对不同年龄段的对象分配原则如下：

- 优先分配到Eden。
- 大对象直接分配到老年代
  - 尽量避免出现较大对象。
- 长期存活的对象分配到老年代。
- 动态对象年龄判断
  - 如果Survivor区中，所有年龄相同的对象的大小总和，大于Survivor区空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需年龄增长至阈值。
- 空间分配担保
  - `-XX:HandlePromotionFailure`，将Survivor区中无法容纳的对象直接放置在老年代。前提是老年代也有空间容纳。



## 为对象分配内存：TLAB

### 为什么要设置TLAB

- 堆区是线程共享区域，任何线程都可以访问堆区中的共享数据。
- 由于对象实例在JVM中的创建十分频繁，在并发环境下从堆区中划分空间是线程不安全的。
- 为了避免多个线程操作同一地址，需要加锁机制，进而会影响分配速度。

### 什么是TLAB

- 从内存模型，而不是垃圾回收的角度，对Eden进行划分。JVM为每个线程分配了一个线程私有缓存区域。
- 多线程同时分配内存时，TLAB可以避免一系列线程安全问题。同时还可以提升内存分配的吞吐量，被称为快速分配策略。

尽管不是所有的对象实例都能在TLAB中创建，但是TLAB是JVM作为内存分配的首选。

默认情况下，TLAB很小，只占Eden的百分之一。

一旦对象在TLAB中分配内存失败时，JVM就会尝试通过加锁机制确保数据操作的原子性，从而直接在Eden中分配内存。

![](../img/TLAB.png)

## 小结：堆空间的参数设置

| 参数                     | 作用                     |
| ------------------------ | ------------------------ |
| `-XX:+PrintFlagsInitial` | 查看所有参数的默认配置   |
| `-XX:+PirntFlagsFinal`   | 查看所有参数的最终值     |
| `-Xms:`                  | 设置初始堆空间大小       |
| `-Xmx:`                  | 设置堆空间最大值         |
| `-Xmn:`                  | 设置新生代的大小         |
| `-XX:NewRatio:`          | 设置新生代和老年代的比例 |



## 堆是分配对象的唯一选择吗

不是。

在Java虚拟机中，对象是在堆中分配内存的，这是一个普遍常识。但是有一种特殊情况，如果经过*逃逸分析(Escape Analysis)*后发现，一个对象并没有逃逸出去的话，那么就可能被优化为栈上分配。

这样就无需在堆中分配内存，也无需进行垃圾回收，这是最常见的堆外存储技术。

另外，基于OpenJDK深度定制的TaoBao VM，实现了GCIH(GC invisible heap)。将生命周期较长的对象从堆中转移到堆外，并且GC不能管理GCIH内部的对象，以此来降低垃圾回收的频率，提高GC的效率。

### 逃逸分析

是一种可以有效减少Java中同步负载和内存堆分配压力的跨函数，全局数据流分析算法。

通过逃逸分析，可以分析出一个新的对象的引用的使用范围，从而决定是否要分配在堆中。

逃逸分析的基本行为就是分析对象的动态作用域：

- 如果一个对象在方法中被定义后，对象只在方法内部使用，就认为对象没有逃逸。
- 当一个对象方法中被定义后，他被方法外部所引用，就认为发生了逃逸。例如作为调用参数传给了其他方法。

没有逃逸的对象可以分配在栈上，这样随着方法的结束，栈帧弹出，对象就会被移除。从而避免了垃圾回收。

一般对应如下情况：

- 给成员变量赋值
- 作为方法返回值
- 实例引用传递(方法传入参数)

#### 代码优化

- 栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被创建，要使指向该对象的引用永远不会被逃逸，对象可能是栈分配的候选，而不是堆分配。
- 同步省略：如果一个对象只能被一个线程访问到，那么对于这个对象可以考虑不同步。(不加锁)。
  - JIT可以通过逃逸分析来判断一个同步块使用的锁对象能否只被一个线程访问，如果是，就会消除同步，称为锁消除。
- 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在，也可以被访问到，那么对象的部分或全部可以不存储在内存中，可以存储在CPU寄存器中。

#### 逃逸分析并不成熟

逃逸分析不能保证其自身带来的消耗会小于被优化代码的消耗。逃逸分析也是一个相对较为耗时的操作。

但是，它仍然是JIT编译器的重要手段。



# 第九章 方法区

## 栈、堆、方法区的交互关系

![](../img/runtimeMemoryII.png)





## 方法区的理解

![](../img/objectReference.png)

当使用`new`关键字创建对象时，需要用一个类型指针来接受该对象的引用。该类型的数据，即Class对象存储在方法区。对象的引用指向堆中对象的实例，堆中对象实例有一个指针指向了该对象的类型数据在方法区中的位置。

元空间不在虚拟机设置的内存中，而是直接使用本地内存，即计算机的物理内存。

## 设置方法区的大小与OOM

jdk7以前，OOM为`OutOfMemoryError: PermGen space`

jdk8以后，OOM为`OutOfMemoryError: Metaspace`

加载了过多的类，就会出现OOM。

## 方法区的内部结构

主要存放：

- 类型信息：Class对象
- 运行时常量池
- 静态变量
- JIT代码缓存
- 域信息
- 方法信息



### 类型信息

对每个加载的类型(类class，接口interface，枚举enum，注解annotation)，JVM必须在方法区中存储以下类型信息：

- 该类型的完整有效名称(全类名 = 包名.类名)
- 该类型直接父类的完整有效名称(对于interface 或是` java.lang.Object` 没有父类)
- 该类型的修饰符(public，abstract，final的某个子集)
- 该类型直接接口的一个有序列表

还要记录当前类型是被哪个加载器加载的。

### 域信息(Field)

- JVM必须在方法区中保存类型的所有与域的相关信息，以及域的声明顺序。
- 域的相关信息包括：域名称、域类型、域修饰符(public, private, protected, static, final, volatile, transient的某个子集)



### 方法信息

JVM必须保存所有方法的信息，包括声明顺序：

- 方法名称
- 方法的返回值类型或(void)
- 方法参数的数量和类型(按顺序)
- 方法的修饰符
- 方法的字节码(bytecodes)、操作数栈、局部变量表及其大小(abstract和native方法除外)
- 异常表(abstract和native方法除外)
  - 每个异常处理的开始位置，结束位置，代码错误处理在程序计数器中的偏移地址，被捕获的异常类的常量池索引(符号引用)。



### non-final的类变量(static)

静态变量和类关联子啊一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分。

类变量被类的所有实例共享，即使没有类实例也可以直接访问他们。

### 全局常量(static final)

被声明为`final`的类变量的处理方法不同，每个全局常量在编译的时候，就会被分配。

也就是说，在编译的时候，就会给该变量分配空间。而`non-final`的静态变量，只有在加载的时候才会分配空间。会在准备阶段赋零值，在初始化阶段赋初值。


### 运行时常量池 vs 常量池

方法区内部包含了运行时常量池。字节码文件包含了常量池。

字节码文件中主要包含三部分：
- 类的基本信息
- 方法的基本信息
- 常量池

常量池中主要存放两类数据：
- 字面量。
    - String类型的字符串值，或被定义为`final`的常量值。
- 符号引用。
    - 以字符串的形式，保存被引用对象的类或接口的全限定名，变量或方法的名称，变量或方法的描述信息，`this`等。

当类加载到内存中后，JVM就会将class常量池中的内容存放到运行时常量池中；运行时常量池里面存储的主要是编译期间生成的字面量、符号引用等等。

类加载在链接环节的解析过程，会符号引用转换成直接引用（静态链接）。此处得到的**直接引用**也是放到运行时常量池中的。

运行期间可以动态放入新的常量。


### 字符串常量池

JDK1.8之后，字符串常量池是存储在堆空间中的，因为字符串会频繁的创建，如果放在元空间中会容易出现OOM。因此，只在元空间中存放字符串的引用，字符串本体还是放在堆中。`String.intern()`方法，就是将字符串放入了字符串常量池中，将其引用保存在了元空间中。

字符串都是`new`出来的，所以本体都在堆空间中。

### 静态变量存放位置

JDK1.8之后，静态变量也存放在堆空间中。

## 方法区的垃圾回收

《Java虚拟机规范》中对方法去的约束是比较宽松的，可以不要求在方法区中实现垃圾回收。

一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这个区域的GC有时又是必要的。

方法区的GC只要回收两个部分：常量池中废弃的常量和不再使用的类型。

HotSpot VM堆常量池的回收策略是比较明确的：只要常量池中的常量没有被任何地方引用，就可以被回收。

## 总结


### 说说JVM内存模型，有哪些分区，分别是干什么的

JVM运行时内存主要包含：虚拟机栈、程序计数器、本地方法栈、堆空间、元空间。其中，虚拟机栈是线程独享的，每一个线程都会创建一个虚拟机栈。其内部结构为一个一个的栈帧，对应着当前线程中的每一次方法调用。栈帧内部又包含了局部变量表、操作数栈、返回地址和附加信息等。

程序计数器，也是线程独享的区域。用于记录当前线程下一条要执行的字节码指令的地址。执行引擎根据程序计数器来取出下一条指令来执行。

本地方法栈，Java虚拟机用于管理本地方法的调用。本地方法就是非Java实现的方法。当一个线程调用本地方法时，它就拥有和JVM同样的权限，可以直接与本地硬件直接交互。可以通过本地方法接口来与运行时数据区来交互，可以与本地处理器的寄存器交互，也可以直接从本地内存中分配任意数量的空间。

堆空间，是线程共享的数据区域。堆空间可以分成：新生代和老年代。新生代又可以划分为Eden区、Survivor0区和Survivor1区。堆空间主要用于存储程序运行时创建的对象，这里也是垃圾回收的最重要的区域。

元空间，JDK8之前称为永久代或方法区。用于存储加载进内存的类的类型信息，方法信息，运行时常量池，静态变量，JIT代码缓存等。

### Java8的内存分代改进

### JVM内存分布/内存结构？堆和栈的区别是什么？堆的结构是什么？为什么要有两个Survivor区？Eden和Survivor区的比例分配是什么？

### 为什么要有新生代和老年代

### JVM运行时数据区的结构，什么时候对象会进入老年代。

### 永久代中会有垃圾回收吗

# 第十章 对象实例化的内存布局与访问布局

## 对象的实例化

### 对象的创建方式

- `new`
- `Class.newInstance()` 反射，只能构造空参构造器。权限只能是`public`。
- `Constructor.newInstance()` 反射，可以调用带参构造器。权限没有要求。
- `clone()` 不调用构造器，但是当前类需要实现`Cloneable`接口。
- 反序列化 从文件、网络中获取一个对象的二进制流。
- 第三方库`Objenesis`

### 创建对象的步骤

1. 加载类元信息
2. 为对象分配空间
3. 处理并发安全问题
4. 执行属性的默认初始化
5. 设置对象头的信息
6. 执行属性的显式初始化、代码块中初始化、构造器初始化

- 判断对象的类是否已经加载、链接、初始化。
    - 当JVM遇到一条`new`指令，首先去元空间中检查该指令的参数能否定位到一个类的符号引用。并检查该类是否已经被加载、解析、初始化。如果没有，在双亲委派机制下，尝试加载该类文件。加载成功生成对应的Class对象。
- 为对象分配内存。 首先，计算对象扎用空间大小，接着在堆中划分一块内存给对象。
    - 如果内存完整 -> 指针碰撞。类似于数组的size，该指针之前的空间都被占用，之后的空间都是空闲的。
    - 如果内存不完整 -> 虚拟机需要维护一个列表，根据列表分配空闲空间
- 处理并发安全问题
    - 采用CAS配上失败重试、区域加锁保护更新的原子性
    - 每个线程预先分配一块TLAB
- 初始化分配到的空间：所有属性设置默认值，保证对象实例字段在不赋值的情况下可以直接使用。
- 设置对象的对象头。
- 执行`init()`方法初始化，即构造器方法。


### 面试题


#### 对象在JVM中的是怎么存储的

#### 对象头信息里面有哪些东西


## 对象的内存布局

Java对象的内存布局包含三部分：对象头(Header)、实例数据(Instance Data)、对齐填充(Padding)。

### 对象头

主要包含两部分：运行时元数据(Mark Word)和类型指针。

- 运行时元数据包含：哈希值、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。
- 类型指针是指向类元数据`InstanceKlass`的指针，确定该对象所属的类型。

> 如果对象是数组，还需要记录数组的长度。
### 实例数据

实例数据是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段)。

存储的规则：

- 相同宽度的字段总是分配在一起。
- 父类中定义的变量会出现在子类之前
- 如果`CompactFields`参数为`true`，子类的窄变量可能插入到父类变量的空隙中。

## 对象的访问定位

JVM如何通过栈帧中的对象引用访问到其指向的对象实例的呢。有两种方式：
- 句柄访问：栈帧中的对象引用，指向的是堆空间中的句柄池的某处。该句柄记录了对象实例数据的指针和对象类型数据的指针。
    - 优点：由于通过句柄池来维护对象实例的位置，所以如果对象发生移动，只需要修改句柄池对应项的内容即可。
    - 缺点：需要维护句柄池，占用了额外空间。另外访问对象实例需要两次索引，时间效率较低。
- 直接指针(HotSpot VM 采用)：栈帧中的对象引用，直接指向了堆空间中的该对象。该对象内部有一个指向类型数据的指针。
    - 优点：能够直接访问到对象实例，时间效率高，空间效率高。
    - 缺点：如果对象在堆空间中的位置发生了变化，此时就需要修改每一处引用。


# 第十一章 直接内存(Direct Memory)


直接内存不是JVM运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。直接内存是在Java堆外的、直接向系统申请的内存空间。

其来源于NIO，通过堆中的DirectByteBuffer操作本地内存。

通常来说直接内存的速度会优于Java堆，读写性能高。

出于性能考虑，频繁读写的场合可能会考虑使用直接内存。

Java的NIO库允许Java程序使用直接内存，用于数据缓冲区。

> 非直接缓冲区，进行I/O时，需要OS由用户态切换到内核态。在用户态，先将I/O数据写在用户态缓存中，然后切换，再从用户态缓存中复制到内核态缓存，最后再去和磁盘交互。
> NIO下，OS划出一部份区域作为直接缓存，该区域可以被Java代码访问到。适合对大文件的读写操作。

直接内存也会导致OOM，默认情况下大小与堆的最大值一致。存在如下缺点：
- 分配回收成本高
- 不说JVM内存回收管理



# 第十二章 执行引擎

## 概述

执行引擎包括：
- 解释器
- JIT编译器
- 垃圾回收

物理机的执行引擎直接建立在处理器、缓存、指令集和操作系统层面上的。而虚拟机的执行引擎是由软件实现的，能够执行不被硬件支持的指令集格式。

JVM的主要任务是负责装载字节码到其内部，但是字节码不能直接运行在操作系统之上，因为字节码指令不是机器码，CPU不能识别。字节码只是一些能被JVM识别的指令、符号表。

如果想让一个Java程序运行起来，执行引擎的任务就是将字节码指令及时/编译为对应平台上的本地机器指令才可以。这就是解释器和JIT的作用。



执行引擎的执行过程：

- 执行引擎究竟执行什么字节码指令，完全取决于PC寄存器。
- 每执行完一条指令，PC寄存器内部就会变为下一条要执行的指令的地址。
- 在执行过程中，执行引擎可能会通过虚拟机栈帧中的局部变量表，根据其中的引用，定位到堆区中的对象实例。以及通过对象头中的元数据指针定位到目标的类型信息。



## Java代码编译和执行过程

![](../img/compileAndExecute.png)

大部分的程序代码转换为物理机的目标代码之前，都需要经过上面的步骤。

绿色的代表编译为字节码文件，加载进JVM，由解释器解释执行。蓝色的表示JIT。

JIT(Just In Time)编译器，虚拟机会将源代码中的热点代码，直接编译为和本地机器相关的机器语言。

有了JIT之后，Java的半编译半执行就变成了，一部分代码解释执行，一部分代码直接编译为机器码。



## 机器码、指令、汇编语言



## 解释器

字节码是一个中间状态，是一种二进制码。它与软件环境和硬件环境都无关，需要解释器翻译为机器码才能执行。Java设计之初就是为了满足跨平台需求，所以避免了静态编译，采用逐行翻译的做法。

解释器一共有两种：

- 古老的字节码解释器：通过软件模拟的方式模拟字节码的执行，效率低下。
- 模板解释器：每一条字节码都与一个模板函数对应，模板函数能直接生成对应的机器码，大大提高效率。

## JIT编译器

### 为什么HotSpot VM要同时拥有解释器和JIT编译器？

当程序启动时，解释器可以立即执行，省去了编译的时间。而JIT想要发挥作用，就需要时间来编译，这会占用一部分时间，但是编译为机器码之后效率更高。

对于服务端来说，启动时间不是重点，所以可以使用JRocket VM，将所有的代码都编译为机器码。而对于一些看重启动时间的场景下，就需要权衡。当JVM启动时，解释器立即执行，可以减少启动时间。而随着时间的推移，JIT发挥作用，将越来越多的字节码编译为本地机器码，提高执行效率。



### 热点代码探测确定何时JIT

Java中的“编译期”是个多义词，可能指将`.java`编译为`.class`文件的过程，也可能指JIT将字节码编译为机器码的过程，也可能指AOT(Ahead Of Time)编译器将`.java`直接编译为机器码的过程。

一个被多次调用的方法，或一个方法内部循环调用较多的循环体，都可以被称之为热点代码。

目前HotSpot VM采用的是基于计数器的热点探测。给每一个方法都建立两个类型的计数器：

- 方法调用计数器：统计方法的调用次数。
- 回边计数器：统计循环体执行的次数。

当一个方法被调用时，先检查该方法是否已经被JIT编译过了，如果存在就优先使用本地代码来执行。如果，没有编译过，就将方法调用计数器加1。然后，判断两个计数器值之和是否超过了设定的阈值，如果超过了，就会立即使用JIT编译该方法。

方法调用计数器并不是统计的精确的次数，而是一个相对的频率。超过一段时间之后，方法还没有达到阈值，那么方法调用计数器的值就会减少一半。称为半衰期。

### 设置模式C1与C2编译器

JVM可以通过参数设置为纯解释模式、纯编译模式和混合模式。

HotSpot VM默认有两个编译器Client Compiler和Server Compiler。

- C1：会对字节码进行简单优化，耗时较少。
- C2：会对字节码进行耗时较长的优化，以及激进优化。



### Graal编译器与AOT编译器

AOT与JIT是一个相对的概念，在程序员运行之前就将字节码转换为机器码。

优点：字节码文件加载进虚拟机之前就已经预编译了，可以直接执行。减少Java应用“第一次启动较慢”的效果。

缺点：破坏了一次编译到处运行的设定，必须为每个机器、OS编译对应的发行包。降低了Java链接的动态性。



# 第十三章 String Table

## String的基本特性

String类的定义为`final`的，不可被继承。内部存储字符串的是`final`修饰的`char[]`。所以String不可变。

### String变量的声明方式

- `String str = "123";`：字面量赋值。
- `String str = new String("123");`

### Java9的变更

Java9种String内部存储结构改为了`byte[]`。原因为：大部分的字符串所包含的字符都可以用一个字节来表示，改为`byte[]`可以节省空间。

基于String的类都做出了修改，如StringBuilder、StringBuffer。

### String的不可变性

String的不可变表现为以下几个方面：

- 当对字符串重新赋值时，需要重新指定内存区域赋值，不能使用原来的`char[] value`来赋值。
- 当对现有的字符串进行拼接操作时，也需要重新制定内存空间。
- 当调用`String#replace`修改字符串时，也需要重新制定内存区域。

#### String与常量池

通过字面量给String对象赋值，此时`char[] value`声明在常量池中。

字符串常量池是不能存储相同内容的字符串的。

- 即字符串在常量池中是唯一的。

为了能够满足这一特性，字符串常量池`String Pool`是一个Hashtable，大小固定，默认长度为1009。如果存放过多的String，就会频繁地哈希碰撞，从而导致链表长度过长，而影响`String#intern`方法的效率。



## String的内存分配

Java7之后，字符串常量池转移到了堆空间中。

Java给八种基本类型和String类型都提供了常量池，为了更快的速度和更省空间。String的常量池比较特殊，使用的方法主要有：

- 通过字面量来声明字符串。`String str = "123";`。此时String对象str会存储在常量池中。
- 如果不是通过字面量声明的变量，可以通过`String#intern`方法，在常量池中创建一个值相同的字符串对象。

> 非基于String的类型，`toString()`方法返回的是一个字面量形式的字符串，所以直接存储在常量池中。
>
> 而基于String的，如StringBuilder，就类似于new String，所以存放在堆中。

## String的基本操作

Java语言规范中规定，完全相同的字符串应当包含同样的Unicode字符序列。并且，必须指向同一个String对象实例。



## 字符串拼接

Java种字符串的拼接有如下几种形式：

- 常量和常量拼接，结果直接在常量池种。这是在编译期就会优化的。
  - 字符串常量池不会存在两个相同的字符串，如果拼接结果已经存在，就不会创建新的。
- 拼接对象只要有一个是变量，结果就存储在堆中。拼接的原理是`StringBuilder`，隐式的实例化一个sb对象完成拼接。
- 如果拼接的结果调用`String#intern`方法，就会主动将字符串放入常量池，并返回地址。



### 底层原理

字符串拼接出现变量时，会先`new StringBuilder()`，然后调用`append()`方法，将所有字符串都拼接进去，最后调用`toString()`，在堆中创建一个String对象。

如果变量被`final`修饰，就变为了常量，就不会使用StringBuilder来拼接。

每次有变量参与的拼接，都会new一个StringBuilder，返回时还会创建一个String对象，效率较低。

建议自己使用StringBuilder来拼接。



## intern()

*JDK8中，intern不会创建对象，而是将当前字符串对象的地址，记录在了字符串常量池中。*

如果通过字面量的方式创建字符串，会直接将字符串创建在字符串常量池中。

如果通过`new String("123")`创建字符串，其实对应的是两个语句`String s = "123"; String str = new String(s);`。所以，会先尝试在常量池中创建一个对象，然后再去堆空间中创建一个对象。

> 使用new关键字一定会创建一个对象。

如果不是通过字面量的方式创建String对象，可以调用`intern()`方法。该方法会先查询字符串常量池中是否已经存在该字符串。

如果常量池中已经存在了该对象，就直接返回常量池中对象的引用，不会创建新的。

如果常量池中不存在该字符串，就会将当前当前字符串的引用记录在字符串常量池中，并返回引用。



### 如何保证字符串的引用指向的是常量池中的对象

- 使用字面量的方式声明字符串`String str = "123";`
- 调用`intern()`方法，`String str = new String("123").intern();` 或 `String str = new StringBuilder("123").toString().intern();`



### 举例

```java
public static void main(String[] args) {
    String s1 = new String("1");
    s1.intern();
    String s2 = "1";
    sout(s1 == s2); // false
    
    String s3 = new String("1") + new String("1");
    s3.intern();
    String s4 = "11";
    sout(s3 == s4); // true
}
```

首先，`s1 == s2`为false，因为s1对象本身是存储在堆空间中的，即便调用了intern，其本身不会发生变化(况且即便不调用intern，也会在常量池创建“1”)。s2直接指向的是常量池中的字符串对象。

然后，s3首先会创建两个`"1"`对象，然后通过StringBuilder来拼接对象，最后返回的是存储在堆中的s3，且此时字符串常量池中没有"11"字符串。接着执行intern，才将“11”在堆中的地址记录在常量池中。s4直接引用的是常量池中的对象，所以其地址就是s3的地址。

如果交换代码顺序就会出现不同结果。

```java
public static void main(String[] args) {
    String s3 = new String("1") + new String("1");
    String s4 = "11";
    s3.intern();
    sout(s3 == s4); // false
}
```

s3在堆上创建后，此时字符串常量池中只有"1"。然后在常量池中创建“11”。s3执行intern时，直接返回的是s4的地址，因此两个字符串变量地址不相同。

```java
public static void main(String[] args) {
    String s = new String("a") + new String("b");
    String s2 = s.intern(); // 创建了对象
    String s3 = "ab";
    sout(s2 == s3); // true
    sout(s == s3); // false
}
```

```java
public static void main(String[] args) {
    String s = new String("a") + new String("b");
    s.intern(); // 发生了对象创建，地址不一致
    String s2 = "ab";
    sout(s == s2); // false
}
```



### 面试题`new String("abc");`会创建几个对象

1个或2个。使用`new`关键字创建String对象，相当于两个语句`String s = "abc"; String str = new String(s);`。

如果常量池中没有存在该字符串，会先在常量池中创建，然后再在堆中创建。

如果常量池种已经存在该字符串，只会在堆中创建。



### `new String("a") + new String("b")`会创建几个对象

5个或几个。

对于a和b，其创建过程都和上一题一致。然后因为涉及到字符串拼接，会使用StringBuilder对象，然后调用toString()方法。因此，最多创建5个。

> toString只会在对中创建字符串对象，而new会先在常量池中创建，再去堆中创建。
>
> 虽然StringBuilder#toString也是调用的`new`关键字，但是构造器不是同一个。只会在对中创建对象。

## StringTable垃圾回收

StringTable中会发生垃圾回收。


# 第十四章 垃圾回收概述

## 什么是垃圾

垃圾是指没有任何指针指向的对象实例，这个对象就是需要被回收的垃圾。如果不及时进行垃圾回收，那么这些垃圾对象就会一直占用着内存空间直到程序结束。被保留的空间无法被其他对象使用，长此以往甚至会导致OOM。

## 为什么需要GC

对于高级语言来说，一个基本认知就是如果不进行垃圾回收，内存迟早会被消耗完。因为，不断地进行内存分配而不进行回收，就好像不停生产生活垃圾而从来不打扫一样。

除了释放没用的对象外，垃圾回收也可以清理内存里的记录碎片。碎片整理会将碎片空间整合在一起，以便JVM后续分配空间给新的对象。

随着应用程序的扩张，如果不进行垃圾回收，就不能保证应用程序的正常运行。而GC时造成的STW又跟不上实际的需求，才会不断优化GC。

## 早期垃圾回收

在C/C++时代，内存空间的申请和释放都需要程序员手动操作。但是由于程序员问题忘记释放空间，就会产生内存泄漏。随着时间的增长可能会造成OOM。

## JVM垃圾回收机制

Java提供自动内存管理，降低了内存泄漏和内存溢出的风险。

但是过度依赖自动管理，就会弱化再出现内存泄漏和内存溢出时的处理能力。要能够快速根据日志定位到问题和解决问题。

Java的GC作用的内存区域为堆区和方法区(较少GC)。从GC的频率来讲：
- 频繁回收YoungGen(年轻代)。
- 较少回收OldGen(老年代)。
- 基本不动Perm区(永久代、方法区、元空间)。


# 第十五章 垃圾回收相关算法

## 标记阶段：引用计数算法

### 垃圾标记阶段：判断对象存活

堆区中存放着几乎所有的对象实例，在GC之前，首席需要判断哪些对象是存活对象，哪些是已经死亡的对象。只有已经标记为死亡的对象，才会在GC时释放其空间。这个阶段被称为垃圾标记阶段。

*判断标准*：当一个对象已经不被任何的存活对象引用时，就可以标记为死亡。

判断方法有两种：*引用计数法*和*可达性分析法*。

### 引用计数法

为每一个对象保存一个*整型*的**引用计数器属性**，用于记录对象被引用的情况。

对于任意的对象A，如果有任何对象引用了A，A的引用计数器就加1；当引用失效时，A的引用计数器就减1。只要A的引用计数器为0，就表示A不可能再被其他对象引用(没人能找到它了)，可以进行回收。

优点：实现简单，垃圾对象便于识别。判定效率高，回收没有延迟。

缺点：
- 需要单独的字段存储引用计数器，增加了存储空间的开销。
- 每次赋值都需要更新引用计数器，增加了时间开销。
- 无法处理*循环引用问题*，这是致命缺陷，导致没有使用该算法。

> 循环引用就是内存泄露的一种形式。

Python使用了引用计数算法，因为吞吐量比较大。如何解决循环引用问题？在合适的时机手动解除，以及使用弱引用weakref。

## 标记阶段：可达性分析算法

同样具备简单高效的特点，同时能够解决循环引用的问题，防止内存泄露的发生。是Java、C#的选择。这种类型的垃圾收集也被称为追踪性垃圾收集。

基本思路：
- 可达性分析就是以根对象集合(GC Roots)为起点，自顶向下地搜索被根对象集合所链接的目标对象是否可达。
- 使用该算法，内存中存活对象都会被根对象直接或间接链接，搜索所走过的路径被称为*引用链*(Reference Chain)。
- 如果目标对象没有任何引用链相连，则不可达。意味着对象已经死亡，可以被标记为垃圾对象。
- 只有和根对象存在引用链的对象才是存活对象。

### 面试问题：根对象都有哪些

在Java中，根对象包含以下几类元素：
- 虚拟机栈中的引用对象。
  - 各个线程中被调用方法中使用的参数、局部变量等。
- 本地方法栈内JNI(即本地方法)引用的对象。
- 方法区中静态属性所引用的对象。
  - Java引用类型静态变量。
- 方法区中常量的引用对象。
  - 如字符串常量池中的引用。
- 所有被同步锁sychronized持有的对象。
- Java虚拟机内部的引用。
  - 基本类型数据对应的Class对象，一些常驻的异常对象(NullPointerException、OutOfMemoryException)。
- 反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
- 除了固定的GC Roots外，根据用户所选择的GC以及当前回收区域的不同，还可以有其他对象“临时性”地加入，共同构成了GC Roots集合。如分代收集和局部回收(Partial GC)。
  - 如果只是针对Java堆中的某一块区域进行GC，必须考虑到内存区域是JVM自己的实现，不是孤立封闭的，该区域的对象完全有可能被其他区域的对象所引用。此时就需要将并联的区域的对象一起加入GC Roots集合中考虑，才能保证可达性分析的准确性。
  - 小技巧：由于Root采用栈的方式存放变量和指针，所以，如果一个指针，它保存了堆内的对象，但是自己又不在堆中，那么它就是一个Root。

为了保证准确性，可达性分析必须在一个保证一致性的快照中进行。这点也是导致STW的重要原因。即使是号称不会STW的CMS，在*枚举根节点时*也必须要暂停。

## 对象的finalization机制

Java提供了对象的终止机制(finalization)来允许开发人员提供对象被销毁之前的自定义处理逻辑。

当JVM发现一个对象没有被引用指向，在回收此对象之前，会先调用对象的`finalize()`方法。

`finalize()`方法可以被子类重写，用于在对象被回收之前的资源释放。通常被用于关闭文件、套接字和数据库等。

永远不要主动调用`finalize()`，应该交给垃圾回收器来处理，理由如下：
- 在`finalize()`时，对象可能复活。
- `finalize()`方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，如果不发生垃圾回收，`finalize()`可能永远不会被执行。
- `finalize()`如果写的很烂，会影响GC的性能。

由于`finalize()`的存在，JVM中的对象可能有三种状态：
- 可触及的：从根节点开始能够访问到该对象。
- 可复活的：对象的所有引用都被释放，但是对象可能在`finalize()`中复活。
- 不可触及的：对象的`finalize()`被调用，并且没有复活，那么就会进入不可触及状态。这种状态下，对象不可能复活。因为`finalize()`方法只能被调用一次。

> 如果从所有的根对象出发都无法访问到某个对象，表明该对象已经不再使用。但是此时该对象并不是一定会死亡，而是处于死缓状态，即可复活状态。

判断一个对象是否可回收，至少要经过两次标记过程：
- 如果对象obj到GC Roots没有引用链，则进行第一次标记。
- 进行筛选，判断该对象是否有必要执行`finalize()`方法。
  - 如果obj没有重写该方法，则认为没有必要调用。obj被判定为不可触及的。
  - 如果obj重写了该方法，且还未执行过，那么obj会被放入F-Queue队列中。由JVM自动创建的、低优先级的Finalizer线程触发队列中对象的`finalize()`方法执行。
  - `finalize()`是对象逃脱死亡的最后机会，稍后GC会对F-Queue中的对象进行第二次标记。如果obj在该方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，obj会被移除“即将回收”集合。如果之后obj再次变为垃圾，则不可能再次被执行`finalize()`，一个对象只会被执行一次。

## MAT与JProfiler的GC Roots溯源

## 清除阶段：标记-清除算法(Mark-Sweep)

标记阶段的任务就是区分出内存中存活的和死亡的对象，下一个阶段为清除阶段，GC的任务就是执行垃圾回收，释放掉死亡对象的空间。

标记清除算法，当堆中的有效空间(available memory)被耗尽时，就会停止整个程序(stop the work)，然后进行两项工作：
- 标记：Collector从根引用节点开始遍历，标记所有被引用的对象。一般是在对象头中记录为可达对象。
- 清除：Collector对堆内存从头到尾遍历，如果发现某个对象不可达，将其回收。

优点：
- 思路简单。

缺点：
- 效率低。
- 进行GC时需要停止整个程序，用户体验差。
- 清理出来的空间不是连续的，产生内存碎片。需要单独维护一个空闲列表。

> 清除不是真的擦除，只是将该空间标记为可用，下次可以直接分配给其他对象。

## 清除阶段：复制算法(Copying)

核心思想：将内存空间划分为两部分，每次只使用其中一部分。在垃圾回收时，先将存活对象复制到另一区域，然后将该区域标记为正在使用，另一侧为空闲区。因为死亡的对象没有被复制过来，所以相当于被清除了。复制过后，空闲区域是连续的，没有碎片。(类似于Survivor区的做法)

优点：没有标记和清楚过程，实现简单，运行高效。复制过后能够保证空间的连续性。

缺点：
- 需要两倍的内存空间。
- 对于G1这种分拆为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象的引用关系。时空开销都很大。

特点：如果垃圾对象很少，那么需要复制的对象数量就非常多。导致效率很低。

根据这一特点，可以将其运用在新生代，因为这里存活对象较少。

## 清除阶段：标记-压缩算法(Mark-Compact)

复制算法的特性决定了它不适合用在老年代上，因为每次都需要复制大量的对象。

执行过程：
- 标记：从根引用节点出发，将遍历到的对象标记为可达。
- 压缩：将所有存活对象压缩到内存的一端，按顺序存放。之后清除剩余区域的对象。

其效果就像是标记清除算法后，再进行一次内存整理。两者之间的本质区别就是前者是非移动式的，后者是移动式的。

由于没有碎片，JVM只需要维护空闲区域的起始位置即可，成本降低。

优点：
- 没有碎片。
- 消除了复制算法需要两倍内存的问题。

缺点：
- 从效率上来讲，低于复制算法。
- 移动对象的同时，如果对象被其他对象引用，需要调整指针。
- 移动过程需要停止程序，即STW。

## 小结

||Mark-Sweep|Copying|Mark-Compact|
|---|---|---|---|
|速度|中等|最快|最慢|
|空间开销|少(有碎片)|两倍存活对象的大小(无碎片)|少(无碎片)|
|移动对象|否|是|是|

## 分代收集算法

年轻代的垃圾回收：年轻代的特点是对象生命周期短，存活率低，回收频繁。因此复制算法比较适合年轻代。而其空间利用率不高的问题，通过Survivor区得到解决。

> 因为Eden区的存活对象直接复制到了Survivor，因此Eden内部不需要保留一部分空间作为复制。因此只浪费了十分之一的空间。

老年代的垃圾回收：老年代的特点是对象生命周期长，存活率高，回收不频繁。因此，一般是标记清除算法和标记压缩算法混合实现。
- Mark阶段的开销与存活对象的数量成正比。
- Sweep阶段的开销与空闲空间数量成正比。
- Compact阶段的开销与存活对象的数量成正比。

## 增量收集算法、分区算法

### 增量收集算法

之前介绍的算法或多或少都会引起STW。增量收集算法就是为了解决STW。

基本思想：如果一次将所有垃圾都清除会造成系统行时间停顿，那么就可以让垃圾回收线程和用户线程交替执行。每次，垃圾回收线程只处理内存空间的一小部分，然后继续让用户线程执行，如此反复直到所有垃圾都被清理。

通过对线程空间冲突的妥善处理，允许垃圾回收线程以分阶段的方式完成标记、清理、或复制工作。

缺点：线程切换和上下文转换的消耗，使得垃圾回收的总体成本上升，降低了吞吐量。

### 分区算法

一般来说，相同条件下堆空间越大，一次GC消耗的时间就越长，产生的停顿时间也越长。为了能更好地控制GC产生的停顿时间，将一块大的内存分割成多个小块，每块空间独立使用。


# 第十六章 垃圾回收的相关概念

## System.gc()的理解

在默认情况下，调用`System.gc()`或`Runtime.getRuntime().gc()`会显式触发*Full GC*。同时对新生代和老年代进行垃圾回收。

但是`System.gc()`调用附带一个免责声明，无法保证对垃圾收集器调用的时间(可能过了很久才会调用)。因为，一般情况下GC都应该是自动进行的，无需手动触发，否则过于麻烦。

## 内存溢出与内存泄漏

### 内存溢出

内存溢出：程序申请的空间大于JVM可用空间。JavaDoc对OOM的解释是，没有空闲空间且垃圾收集器也无法提供更多内存。没有空闲内存的情况为Java对内存不足，原因有二：
- Java虚拟机的堆内存设置不够。比如可能存在内存泄漏；也有可能就是堆空间设置的大小不合理。
- 大妈中创建了大量大对象，并且长时间不能被垃圾收集器收集(存在被引用)。

由于GC一直在发展，所以一般情况下，除非应用程序占用的内存增长速度非常快，使得垃圾回收跟不上内存消耗的速度，否则不太容易出现内存溢出。大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行就进行Full GC，这时就会回收大量的内存。


### 内存泄漏

内存泄漏：指程序运行过程中分配的空间未释放或无法正常释放，造成系统空间的浪费。

严格来说，只有对象不再被程序用到了，但是GC又不能回收它们，才能称之为内存泄漏。但是，有时一些操作会导致对象的生命周期过长，甚至导致OOM，也可以叫做内存泄漏。

虽然，内存泄漏不会立即导致程序崩溃，但是一旦发生内存泄漏，可用内存就会被逐渐消耗，直至耗尽，最终出现OOM。(这里的内存空间不是物理内存，而是虚拟内存)。

举例：运行时实例化了很多对象，对象之间有引用，使用完毕后将其中大部分引用都断开了，但是，有部分引用被忘记断开了。此时申请的对象已经不再使用了，但是从GC的角度看，这些对象还是存活对象(从根节点出发能够触及这些对象)，所以不能进行垃圾收集。
- 单例模式：单例模式下，如果该对象实例引用了一些外部对象，则该外部对象都不会被回收。因为单例模式的对象生命周期很长。
- 一些提供`close()`的资源未关闭：数据库连接(dataSource.getConnection())、网络连接(socket)和I/O都必须手动关闭。

## Stop The World

简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿时，整个应用程序线程都会被暂停，没有任何响应。

> 可达性分析算法中，枚举根节点(GC Roots)会导致所有Java执行线程的停顿。因为分析工作必须在一个能确保一致性的快照中进行，因为如果分析过程中对象的引用关系还在不停变化，分析的结果不能保证准确性。

STW会降低用户体验，因此要尽量减少STW的发生。

STW与使用哪款GC无关，所有的GC都会造成STW。

STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，将用户线程全部暂停。开发中不要使用`System.gc()`，会造成STW(Full GC，暂停时间较长)。

## 垃圾回收的并行与并发

- 并行：多条垃圾回收线程并行工作，但是，用户线程还是阻塞。
- 串行：相较于并行的概念，垃圾回收单线程工作，即只有一个垃圾回收线程。
- 并发：指用户线程和垃圾收集线程同时执行(可能是并发交替执行)。垃圾回收时不会造成用户线程的长时间阻塞。

## 安全点与安全区域

### 安全点

安全点：程序不是在任何时刻都能够停下来开始GC，只能在特定的位置才能停顿。这些位置被称为安全点。

Safe Point的选择很重要，如果太少可能会导致GC等待时间太长，如果太多会导致运行时的性能问题。选择安全垫时，会根据"是否具有让程序长时间执行的特征"的原则选取。即选择执行时间比较长的指令(方法调用、循环跳转和异常跳转)的执行期间作为安全点。

> 安全点选取执行时间长的指令是因为，这些指令执行期间对象的引用通常不会发生变化。

如何能在GC发生时，保证所有线程都执行到最近的安全点停下来呢？
- 抢先式中断(目前没有虚拟机采用)：首先中断所有线程，如果还有线程不在安全点，就恢复线程让其直行至安全点。
- 主动式中断：设置一个中断标志，各个线程运行到安全点后就主动判断该标志，如果中断标致为true，就将自己中断挂起。

### 安全区域

安全点机制保证了程序执行时，每隔一段不长的时间就能走到一个安全点，可以执行GC。但是，当程序处于Sleep或Blocked状态时，就无法响应JVM的中断请求；同样，JVM也不会等待挂起线程被唤醒才进行GC。

此时就需要安全区域来解决。

安全区域：指一段代码片段中，对象的引用关系不会发生变化。这个区域中的任何位置开始GC都是安全的。可以看作是扩展了的安全点。

实际执行时：
- 当线程运行到安全区域时，首件标识出已经进入了Safe Region，如果这段时间内发生GC，JVM就会忽略标识为Safe Region的线程(不检查其是否处于安全点)。
- 当线程离开安全区域时，会检查JVM是否已经执行完GC，如果完成了，就继续运行该线程，否则必须等待GC完成。

## 再谈引用：强引用 -- 不回收

### 四种引用概述

我们希望能够描述这一类对象：当内存空间足够时，能够保留在内存中；如果内存空间在GC后还是很紧张，可以清除这些对象。

JDK1.2之后对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四类。引用的强度依次递减。除了强引用外，其他三种都可以在`java.lang.ref`包中找到。

Reference子类中只有中继器引用是包内可见的，其他三种引用类型都是public修饰。

- 强引用(Strong Reference)：最传统的引用定义，是指程序中普遍存在的引用赋值，类似于`Object obj = new Object()`这种引用关系。无论任何情况下，*只要强引用关系还存在，垃圾收集器就不会回收掉这些对象*。
- 软引用(Soft Reference)：*系统在即将发生内存溢出之前*，会这些对象列入回收范围之中进行二次回收，如果这回收后还没有充足的空间，才会抛出内存溢出异常。
- 弱引用(Weak Reference)：被弱引用关系引用的对象*只能生存到下一次垃圾回收之前*。当GC开始时，无论内存空间是否充足，都会将这些对象回收。
- 虚引用(Phantom Reference)：一个对象是否有虚引用的存在，*完全不会对其生存构成影响*，也无法通过虚引用来获取一个对象的实例。为一个对象设置虚引用的*唯一目的，就是能够在这个对象被回收时收到一个系统通知*。

### 强引用

是Java默认的引用类型。当使用`new`关键字创建一个对象，并将其赋值给一个变量时，该变量就成为指向该对象的一个强引用。

*强引用的对象是可触及的。垃圾回收器永远都不会回收掉被抢强引用指向的对象。*
- 软引用、弱引用和虚引用的对象分别对应：软可达、弱可达和虚可达。

只有当一个对象超出了引用的作用域或显式地将其强引用赋值为null，才可以被当作垃圾来回收。

强引用是造成内存泄露的主要原因之一。

总结：
- 强引用可以访问到对象实例。
- 强引用指向的对象不会被回收。
- 强引用会造成内存泄漏。

## 再谈引用：软引用 -- 空间不足才会回收

用来描述一些还有用，但是非必需的对象。只被软引用关联的对象，在系统将要发生内存溢出时，会将这些对象列入回收范围内进行二次回收。如果这次回收还是没有足够的内存空间，才会抛出内存溢出异常。

软引用通常来实现内存敏感的缓存。如*高速缓存*就有用到软引用，当空间还有空闲就保留缓存，内存不足就清除缓存。

GC在决定回收软可达对象时，会*先清理掉软引用*(此时该引用就无法访问到对象实例了)，并可选地将引用存放在一个引用队列中(Reference Queue)。

JVM会尽量让软引用的存活时间长一些，迫不得已才会清理。

Java提供了`java.lang.ref.SoftReference`类来实现软引用：
```java
Object obj = new Object(); // 强引用
SoftReference<Object> sf = new SoftReference<>(); // 软引用
obj = null; // 销毁强引用
```

软引用也可以访问到对象实例。

## 再谈引用：弱引用 -- 每次GC都会回收

弱引用也是用来描述非必需对象。被弱引用关联的对象，只能存活到下一次GC发生。在GC时只要发现弱引用，不管系统堆空间是否充足，都会将其回收掉。

但是，GC线程优先级通常比较低，因此，并不一定能很快发现弱引用的对象，此时若引用对象就会存活较长时间。

在构造弱引用时，也可以指定一个队列，当若引用对象被回收时，就会加入指定的引用队列。通过这个队列就可以追踪到对象的回收情况。

软引用和弱引用都适合存储可有可无的缓存数据。

> 软引用和弱引用的最大不同就在于，当GC开始时，需要通过算法检查是否回收软引用对象，而弱引用对象GC总是会进行回收。*弱引用对象更容易、更快地被GC会回收*。

可以访问到对象实例。

## 再谈引用：虚引用 -- 只是为了发通知

虚引用不会影响对象的生命周期，也无法访问到对象实例。

*为一个对象设置虚引用地唯一目的就是跟踪垃圾回收过程*。可以在该对象被回收时收到一个系统通知。

由于虚引用可以跟踪对象被回收的时间，因此，可以将一些资源释放在虚引用中执行和记录。

## 再谈引用：终结器引用

FinalReference，用来实现对象的`finalize()`方法。



# 第十七章 垃圾回收器

## GC分类与性能指标

### GC分类

按照线程数分：串行垃圾回收器和并行垃圾回收器。(线程数是指用于垃圾回收的线程数)。
- 串行垃圾回收器是指同一时间只允许一个CPU用于垃圾回收，此时工作线程被暂停，直到垃圾回收结束。
- 并行回收可以运用多个CPU进行垃圾回收。但是，仍然采用独占式，需要STW。

按照工作模式分：并发式垃圾回收器和独占式垃圾回收器。
- 并发式：垃圾回收器与应用程序线程交替工作，以尽可能减少暂停时间。
- 独占式：STW，一旦运行就需要暂停所有用户线程。

按照碎片处理方式分：压缩式和非压缩式。
- 压缩式：会在垃圾回收完成之后，对存活对象进行整理。
- 非压缩式不会进行该步骤。

按照工作的内存区间分：年轻代垃圾回收器和老年代垃圾回收器。

### 性能指标

- 吞吐量：运行用户代码的时间与总运行时间的比例。
- 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。
- 内存占用：Java堆所占内存大小。

上述三个指标构成了“不可能三角”，三者的总体表现会随着技术进步越来越好。三者中，暂停时间的重要性比较高。简单来说，主抓两点：吞吐量和暂停时间。

## 不同的垃圾回收器概述

七种经典垃圾回收器：
- 串行：Serial、Serial Old
- 并行：ParNew、Parallel Scavenge、Parallel Old
- 并发：CMS、G1

垃圾回收器的组合关系：
- 新生代收集器：Serial、ParNew、Parallel Scavenge
- 老年代收集器：Serial Old、Parallel Old、CMS
- 整体收集器：G1

## Serial：串行回收

Serial采用复制算法、串行回收和STW机制的方式进行回收。

Serial Old用于回收老年代的垃圾，采用的是标记压缩算法。

## ParNew：并行回收

可以说ParNew就是Serial的多线程版本。采用的是复制算法、STW。

## Parallel：吞吐量优先

### Parallel Scavenge

采用复制算法、并行回收和STW。其出现的目的是达到一个可控的吞吐量，且有自适应调节策略。

高吞吐量适用于较多的后台运算而不需要太多的交互的任务，如执行批量处理、工资交付、科学计算等任务。

### Parallel Old

采用标记压缩法、并行回收和STW。

## CMS：低延迟

CMS(Concurrent Mark-Sweep)并发标记清除。这款收集器是真正意义上的第一款并发收集器，第一次实现了能够让用户线程和垃圾回收线程同时工作。

其关注点是缩短垃圾收集时用户线程的停顿时间，适合交互较多的应用场景。

采用标记清除算法、并发收集、STW。

### 工作原理

- 初始标记：STW，暂停所有用户线程，对GC Roots能直接关联到的存活对象进行标记。
- 并发标记：从GC Roots直接关联到的对象开始，遍历整个对象图的过程。这个过程耗时较长，但是不需要暂停用户线程。与用户线程并发执行。
- 重新标记：由于在并发标记阶段，用户线程可能会修改引用。为了修正标记变动的那一部分对象，进行重新标记。会产生STW，时间比初始标记稍长。(多线程)
- 并发清除：此阶段清除掉已经死亡的对象。由于不需要移动对象，所以可以并发执行。

### 特点与弊端

- 虽然初始标记和重新标记会产生STW，但是暂停时间不会太长。由于最耗时的并发标记和并发清楚都不需要STW，所以总体上还是并发的。
- 由于工作期间，用户线程没有暂停，所以需要保证用户线程有可用的内存空间。所以，CMS不能像其他GC可以当到老年代几乎全满时才开始垃圾回收。而是到达某一个阈值就开始。
- 如果垃圾回收期间用户线程内存不足，就会出现一次*Concurrent Mode Failure*，然后启用Serial Old来重新进行老年代收集。
- CMS采用的是标记清除算法，因此不可避免的会产生内存碎片。

弊端总结：
- 会产生内存碎片
- CMS收集器对CPU资源非常敏感：并发阶段虽然不会导致用户线程暂停，但是会占用一部分资源，导致用户线程变慢。
- CMS无法处理浮动垃圾：如果在并发标记阶段出现新的垃圾，CMS无法对这些垃圾进行标记。会导致新的垃圾无法及时回收。

## G1：区域化分代式

目标是在延迟可控的情况下，尽量获得高吞吐量。

G1是一个并行回收器，将内存划分为很多不相干的区域，使用不同的Region来表示Eden，幸存者区和老年代，等。

在后台维护一个优先列表，跟踪各个区域的垃圾回收价值，每次根据允许的收集时间，优先回收价值最大的Region。

是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器。官方称之为全功能垃圾收集器。

### 优势与不足

优势：
- 并行与并发：
  - 并行性：G1在工作期间，有多个垃圾回收线程同时工作，此时用户线程STW。
  - 并发性：G1拥有和用户线程交替执行的能力，部分工作可以和应用程序同时进行，一般来说，不会在手机阶段发生完全阻塞用户程序的现象。
- 分代收集：
  - 从分代上看，G1仍然属于分代收集器，会区分Eden、Survivor和老年代。
  - 将堆空间划分为若干个区域，这些区域中包含了逻辑上的年轻代和老年代。
  - 能够同时兼顾年轻代和老年代。
- 空间整合：
  - G1在进行Region的回收时，采用的是复制算法，将当前Region的存活对象复制到一个空闲Region，此时会将存活对象顺序摆放，没有碎片。
- 可预测的停顿时间模型：能让使用者指定在一个长度为M毫秒的时间片段，垃圾回收消耗的时长不超过N毫秒。
  - 由于分区的原因，G1只能对部分内存进行回收，因此全局停顿的情况较少发生。
  - 每次都在允许的时间内，收集最有价值的区域，效率更高。

缺点：
- 进行垃圾收集时占用的内存较高
- 运行时的额外负载较高

### Region的使用

一个region只可能同时充当一种角色：eden、survivor、old、humongous。humongous用来存储巨型对象，如果一个H装不下，就会寻找连续的H来存放。之所以这么做，是因为，短期存在的大对象如果放在old中就会对垃圾回收造成负面影响。但是，为了寻找连续的H，有时不得不进行Full GC。

### G1的回收过程

主要包含以下三个步骤：
- Young GC
- 老年代并发标记过程(Concurrent Marking)
- 混合回收 Mixed GC
- 如果有需要还会进行单线程、独占式的Full GC。 

#### Young GC

当Eden区空间用尽时开始Young GC。这是一个并行的独占式收集器。在Young GC运行期间，会暂停所有的用户线程，启用多线程进行垃圾回收。然后从Eden移动存活对象到Survivor和老年代。

#### Concurrent Marking

当对内存使用到达一定阈值后，开始老年代并发标记过程。

#### Mixed GC

老年代标记完成后，马上开始混合回收过程。G1 GC会从老年代移动对象到空闲Region，G1的老年代回收器不需要回收整个老年代，只需要回收部分Region。会同时回收部分老年代Region和年轻代。

### RSet

每个Region都维护一个RSet，用于记录当前Region中的对象被其他Region引用的情况。当进行垃圾回收时，通过RSet就能直到Region外部的引用有哪些。

每次引用类型数据写操作时，都会产生一个写屏障暂时中断操作，会检查当前引用的对象是否在不同的Region中。如果不同，就通过CardTable把相关引用信息记录在对象实例所在Region的RSet中。

当进行垃圾回收时，将RSet加入GC Roots，就能够保证不需要全局扫描。

### G1回收过程详解-Young GC

JVM启动时，G1会先准备好Eden区，程序运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次YoungGC。

YoungGC只会回收Eden区和Survivor区。

YGC时，首先G1停止应用程序的执行STW，G1创建回收集(Collection Set)，是指需要被回收的Region的集合，YGC回收过程的回收集包含年轻代Eden和Survivor区所有的Region。

Eden和Survivor的Region会将内部存活的对象复制到新的空闲Region，成为新的Survivor Region。也有部分Survivor会将晋升的对象复制到新的空闲Region成为Old Region。

下面为详细回收过程：
1. 扫描根：根是指static变量指向的对象，正在执行的方法调用链上的局部变量等。跟引用连同RSet记录的外部引用作为扫描存活对象的入口。
2. 更新RSet：处理dirty card queue中的card，更新RSet。完成后，RSet可以准确地反映老年代所在的Region中对象的引用。
   1. 当对象被另一个对象引用时，会在dirty card queue中添加一个card，记录引用信息。为什么不直接更新RSet？因为RSet更新需要线程同步。
3. 处理RSet：识别被老年代对象引用的Eden中的对象。这些Eden对象被认为是存活对象。
4. 复制对象：Eden区Region中存活的对象会被复制到Survivor区中空闲的Region；Survivor区中存活对象若年龄未到达阈值，增长1，到达阈值复制到Old区中空闲的Region；如果Survivor区内存不够，Eden区部分数据直接晋升到Old区。
5. 处理引用：处理Soft、Weak、Phantom、Final等引用。最终Eden空间数据清空，GC停止工作。而目标内存中的对象都是连续存储的，没有碎片。

### G1回收过程详解-并发标记过程

1. 初始标记阶段：标记从根节点直接可达的对象。需要STW，并且会触发一次YGC。
2. 根区域扫描：G1扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程一定要在YGC前完成。
3. 并发标记：在整个堆中进行并发标记，此过程可能被YGC中断。如果发现区域中所有对象都是垃圾，这个区域就会被立刻回收。同时，会计算每个区域对象的存活比例。
4. 再次标记：由于上述标记是并发的，应用程序还在进行，需要修正上一次的结果。触发STW。
5. 独占清理：STW，计算各个区域存活对象和GC回收比例，进行排序。识别可以混合回收的区域。实际上不会做出清理动作。
6. 并发清理阶段：识别并清理完全空闲的区域。

### G1回收过程详解-混合回收

并发标记结束后，只是回收了老年代中全部为垃圾的Region，部分为垃圾的Region只是被计算了出来。默认情况下，这些Region会分八次被回收。

混合回收的回收集包括：八分之一的老年代Region，Eden区的所有Region，Survivor区所有Region。混合回收算法和YGC完全一致，只是回收集多了老年代Region。

老年代Region中，垃圾占比越高的越会被先回收。


### G1回收可选过程Full GC

G1的初衷就是要避免Full GC的出现。但是，如果上述方式不能正常工作，G1就会STW，使用单线程的回收算法来回收垃圾，性能非常差。

导致Full GC的原因可能有两个：
- Evacutaion的是有没有to-space来存放晋升的对象。
- 并发标记过程完成之前空间耗尽。

## 总结

## GC日志分析
