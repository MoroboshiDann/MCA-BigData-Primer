# JVM整体介绍

## JVM简介

### 基本概念

​	JVM(Java Virtual Machine)，Java虚拟机。是一种跨语言的平台。JVM只关心字节码文件，不只能够解释运行Java字节码文件，只要语言的编译器遵守相关标准，则JVM就可以解释运行其编译产生的字节码文件。

​	通过JVM可以实现多语言混合编程，各种语言之间的交互不存在任何困难，就像调用自己语言的原生API一样方便，因为他们最终运行在同一个虚拟机上。

### 虚拟机与Java虚拟机

​	虚拟机，就是一台虚拟的计算机。是一款软件，用来执行一系列虚拟计算机指令，大体上可以分为*系统级虚拟机和程序虚拟机*：

- 系统级虚拟机：完全对物理计算机的仿真。
- 程序虚拟机：专门为执行单个计算机程序而设计。

​	无论哪种虚拟机，在其上运行的软件都被限制于虚拟机提供的资源中。

​	Java虚拟机是一台执行Java自己妈的虚拟计算机，拥有独立的运行机制，Java技术的核心就是Java虚拟机。

​	Java虚拟机就是二进制字节码的运行环境。有如下特点：

- 一次编译，到处运行
- 自动内存管理
- 自动垃圾回收功能

### JVM的位置

![](../img/JVMLocation.png)

​	JVM运行在操作系统之上。

## JVM的整体结构

​	![](../img/JVMStructure.png)

​	以上为HotSpot VM。主要分为三大部分：

- 类装载子系统：负责将字节码文件加载到内存中，生成Class对象
- 运行时数据区：运行时内存分布，灰色部分为线程独享
- 执行引擎：解释器、JIT、GC



## Java代码执行流程

- `.java`文件，经过编译器(编译器前端)，生成`.class`文件的二进制字节码
- `.class`文件被类加载子系统加载至内存，生成`Class`对象
- 执行引擎将二进制字节码翻译为机器指令，交给CPU执行，如果有热点代码，会进行缓存(JIT)



## JVM的生命周期

### 虚拟机的启动

​	Java虚拟机的启动时通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的。

### 虚拟机的执行

​	执行一个Java程序时，真正在执行的是一个叫做Java虚拟机的进程。

### 虚拟机的退出

​	有如下几种退出情况：

- 程序正常执行结束
- 程序在执行中发生了异常或者错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止
- 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作
- JNI(Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况



## JVM发展历程

### Sun Classic VM

​	世界上第一款商用Java虚拟机，只提供解释器。jdk1.4被淘汰

## Exact VM

​	Exact Memory Management，准确式内存管理。虚拟机可以知道内存中某个位置的数据具体是什么类型的数据。编译器与解释器混合工作。

## HotSpot VM

​	JDK8中默认的虚拟机。HotSpot指的是它的热点探测技术：

- 通过计数器找到最具编译价值代码，触发即时编译或栈上替换
- 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡

## JRockit VM

​	专注于服务器端应用，可以不太关注程序启动速度，因此，内部不包含解释器实现，全部代码都靠即时编译器编译后执行。

​	世界上最快的JVM。

## IBM J9

​	有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。



# 类加载子系统

​	类加载器的工作原理包含三个阶段：加载阶段、连接阶段和初始化阶段。

- 类加载子系统负责从文件系统或网络中加载`.class`文件，`.class`文件开头有客厅的文件标识。
- ClassLoader只负责`.class`文件的加载，至于其是否可运行，由执行引擎决定。
- 加载的类信息防御一块称为方法区的内存空间。除了类的信息外，方法区中还会存在存放运行时常量池信息，可能还包括字符串字面量和数字常量。

## 加载阶段Loading

- 通过一个类的全限定名获取此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法去这个类的各种数据的访问入口(将类信息存储在方法区)

> 加载`.class`文件的方式：
>
> - 从本地系统中直接加载
> - 从网络获取，如Web Applet
> - 从zip压缩包中读取，为jar，war格式的基础
> - 运行时计算生成，使用最多的是：动态代理技术
> - 由其他文件生成，如：JSP
> - 从专有数据空中提取`.class`文件
> - 从加密文件中获取，典型的防Class文件被反编译的保护措施



## 连接阶段Linking

### 验证Verify

​	验证的目的在于确保Class文件的字节楼中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。主要包含四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。

### 准备Prepare

​	为类变量分配内存并设置该类变量的默认初始值，即零值。

- 所有的变量都会被赋予默认值，而不是实际的赋值。
- 这里不包含使用`final`修饰的`static`元素，因为`final`在编译时就会分配内存，准备阶段会显示初始化。

- 不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量时会随着对象一起分配到Java堆中。

### 解析Resolve

​	将常量池内的符号引用转换为直接引用的过程。事实上，解析操作往往会伴随着JVM在执行完初始化之后完成。

> 如`System.out.pringln("hello world");`中是通过符号引用了`java.lang.System`类中的方法，在解析阶段，会直接指向该类对象，转换为直接引用。

## 初始化Initialization

​	初始化阶段就是执行类构造器方法`<clinit>()`的过程。此方法不需要定义，是javac编译器自动收集类中所有变量的赋值动作和静态代码块中的语句合并而来。

​	类构造器方法中指令按照语句在源文件中出现的顺序执行。

```java
public class Test {
	private static int num = 1;
	static {
		num = 10;
		number = 20;
        sout(number); // 会报错，非法前向引用
	}
	private static int number = 10;
	public static void main(String[] args) {
		sout(num); // 10
		sout(number); // 10
	}
}
```

> 上述代码中，首先，`number`可以先赋值，再定义，这是因为在准备阶段，会对`number`进行赋零值操作。但是，如果在静态代码块中就直接输出`number`，就会报错。
>
> 然后，在`<clinit>()`方法中，会先对`num`赋值为1，再赋值为10。对`number`先赋值为20，再赋值为10，按照顺序操作。

​	`<clinit>()`方法不同于类的构造器。类的构造器在虚拟机中为`<init>()`。

> 如果类中不存在静态变量和代码块，就不会生成`<clinit>()`类构造器方法。
>
> 任何一个类声明之后，都会至少存在一个类的构造方法。

​	若当前类具有父类，JVM会保证子类的`<clinit>()`执行前，让父类的`<clinit>()`执行完毕。

​	虚拟机必须保证一个类的`<clinit>()`方法在多线程下被同步加锁。

> 保证一个类只会被加载一次。一个线程加载成功，其他线程都会被阻塞。



## 类加载器的分类

![](../img/ClassLoaderType.png)

​	图中的四种类加载器是包含关系，不是继承关系。

​	JVM支持两种类型的类加载器，分别为引导类加载器(Bootstrap ClassLoader)和自定义类加载器(User-Defined ClassLoader)。

​	只要是直接或间接继承自ClassLoader的类加载器都是自定义类加载器。常见的类加载器只有三个：

- Bootstrap ClassLoader：系统核心类库，使用该引导类加载器进行加载。无法直接获取该类加载器。
- Extension ClassLoader：扩展类加载器。
- System ClassLoader：用户自定义类，默认使用系统类加载器进行加载

```java
public class Test {
	public static void main(String[] args) {
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        ClassLoader extensionClassLoader = systemClassLoader.getParent();
        ClassLoader bootstrapClassLoader = extensionClassLoader.getParent(); // null
        // 用户自定义类加载器
        ClassLoader classLoader = Test.class.getClassLoader();
        sout(classLoader.equals(systemClassLoader)); // true
        // 系统核心类的加载器
        // 用户自定义类加载器
        ClassLoader classLoader1 = String.class.getClassLoader(); // null
    }
}
```



### 虚拟机自带的类加载器

#### 启动类加载器 Bootstrap ClassLoader

- 该类加载器使用C/C++实现的，嵌在JVM内部。
- 使用该类加载器来加载Java的核心类库，如`JAVA_HOME/jre/lib/rt.jar`、`resources.jar`或`sun.boot.class.path`下的内容。用于提供Java自身需要的类。
- 不继承自`java.lang.ClassLoader`，没有父加载器。
- 负责加载*扩展类加载器*和*应用程序类加载器*，并且是这两个类加载器的父类加载器。
- 出于安全考虑，启动类加载器只加载包名为`java`、`javax`和`sun`开头的类。

#### 扩展类加载器 Extension ClassLoader

- Java语言编写，由`sun.misc.Launcher$ExtClassLoader`实现。
- 派生于ClassLoader类。
- 父加载器为`Bootstrap ClassLoader`启动类加载器。
- 从`java.ext.dirs`系统属性所指定的目录加载类库，或从`JAVA_HOME/jre/lib/ext`子目录下加载类库。如果用户创建的jar包也放在该目录下，也会由该类加载器加载。

#### 系统类加载器/应用程序类加载器 System ClassLoader/AppClassLoader

- Java语言编写，由`sun.misc.Launcher$AppClassLoader`实现。
- 派生于ClassLoader类。
- 父类加载器为`ExtensionClassLoader`扩展类加载器。
- 负责加载环境变量`classpath`或系统属性`java.class.path`指定路径下的类库。
- *该类加载器是程序中默认的类加载器*，一般来说Java应用的类都是由其完成加载。
- 通过`ClassLoader.getSystemClassLoader()`方法可以获取该来加载器实例对象。



### 用户自定义类加载器

​	Java应用的开发中，类的加载几乎都是上述三种类加载器完成的。必要时，我们也可以自定义类加载器。

​	为什么需要自定义类加载器：

- 隔离加载类：可以避免不同模块之间jar包冲突。
- 修改类的加载方式：
- 扩展加载源
- 防止源码泄露：可以在生成字节码文件时进行加密，在加载字节码时进行解密。

​	使用方法：

- 可以通过继承`java.lang.ClassLoader`类的方式，实现自己的类加载器，以满足一些需求。
- 建议将自己的类加载逻辑写在`findClass()`方法中。
- 如果没有特殊需求，可以直接继承`URLClassLoader`类，能够避免自己编写`findClass()`方法，及获取字节码流的方法。



## ClassLoader

​	ClassLoader是一个抽象类，除了BootstrapClassLoader外，所有的类加载器都继承自它。

​	常用方法和获取方式：

- `Class.forName("java.lang.String").getClassLoader();`
- `Thread.currentThread().getContextClassLoader();`
- `ClassLoader.getSystemClassLoader();`
- `getParent`：获取父类加载器，注意不是继承的父类，而是前置。



## 双亲委派机制

​	Java虚拟机对`.class`文件采用的是按需加载的方式。也就是说当需要使用该类时，才会将它的`.class`文件加载到内存生成Class对象。而且加载某个类的`.class`文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。

![](../img/ParentSubmisson.png)

​	其工作原理如下：

- 当一个类加载器收到了类加载请求，它不会自己先去加载，而是将请求交付给父类加载器去执行。
- 如果父类加载器还存在父类加载器，则进一步向上委派。请求最终会到达启动类加载器。
- 如果父类加载器能够完成请求，就返回成功；如果父类返回失败，则子类会尝试加载。

> ​	验证：可以在项目目录中创建一个`java.lang`包，并创建一个`String`类，然后new一个String对象。结果会发现，new出来的还是Java自带的`java.lang.String`，而不是我们自己创建的String。
>
> ​	这是因为通过双亲委派机制，类的加载请求会不断向上委托，String类最终会由Bootstrap ClassLoader来加载，而它只会加载指定目录下的Java核心类库。
>
> ​	同时，如果在自定义的String类中调用main方法，会报错，说找不到main方法，原因同上。

​	`rt.jar`包中的SPI接口，其实现类是由第三方提供的`jdbc.jar`，所以，接口为核心类库，实现类是第三方类库。这种情况下就会出现反向委派，接口由启动类加载器加载，实现类的加载委派给Context ClassLoader，线程上下文类加载器来加载。

​	

​	双亲委派机制的优势：

- 避免类的重复加载
- 保护程序安全，避免核心API被篡改
  - 如上面提到的自定义`java.lang.String`
  - 或者自己创建一个`java.lang.MyTest`类，此时类的包名是`java`，会由启动类加载器来加载，因此会报错，提示不允许访问。防止恶意破坏启动类加载器。



## 沙箱安全机制

​	上文中提到的自定义`java.lang.String`，如果运行main方法，就会加载Java核心类库中的String类，然后从其中找到main方法。但是，因为Java自带的String没有main方法，就会报错。这就是沙箱安全机制，可以保护核心代码不受恶意侵害。



## 其他

### 区分两个类的方式

​	在JVM中，区分两个类是否是一个类有两个必要条件：

- 两个类的完整类名必须一致。
- 加载这两个类的类加载器必须一致，必须是同一个实例。

​	因此，即使是同一个类被同一个JVM所加载，但是只要是加载时使用的类加载器不是同一个实例，那么产生的两个Class对象也是不同的。

​	Java类加载器这种特性可以简单的总结为**命名空间**。即在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。

​	JVM必须知道一个类是由启动类加载器加载的，还是由用户类加载器加载的。如果一个类是由用户类加载器加载的，JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用时，JVM需要保证这两个类的类加载器是相同的。



### 类的主动使用与被动使用

​	Java程序对类的使用分为主动使用和被动使用，主动使用分为七种：

- 创建类的实例
- 调用某个类或接口的静态变量，或对该静态变量赋值
- 调用类的静态方法
- 反射，如`Class.forName("java.lang.String");`
- 初始化一个类的子类
- Java虚拟机启动时被标记为启动类的类
- 动态语言

​	除了以上七种情况，类的使用都会被看做是被动使用，不会导致类的初始化。



# 运行时数据区概述及线程

## 概述

![](../img/RuntimeMemory.png)

​	不同JVM的运行时内存各有同，以上为HotSpot VM的运行时内存，分为：

- 本地方法栈：用来存储C/C++编写的本地的方法(native method)。
- 程序计数器(Program Conter Register)：PC用来记录当前程序下一条指令的地址。
- 虚拟机栈(JVM Stack)：每调用一个方法，压入一个栈帧。
- 堆区(Heap)：包含新生代和老年代。
- 元数据区(Metaspace)：常量池、方法元信息、klass类元信息。
- CodeCache：JIT编译产物。

​	JVM的运行时数据区，一部分会随着JVM的创建而创建，随着JVM的退出而销毁，即随进程变化。另一部分随着线程的生命周期变化。

​	本地方法栈、虚拟机栈和程序计数器是每个线程独一份的。方法区(非堆空间)和堆区是线程共享的。

> 每个Java程序只有一个Runtime对象，可以通过它和运行时环境(运行时内存)进行交互。



## 线程

​	线程是进程的一个运行单元，JVM允许一个进程有多个并行执行的线程。

​	在HotSpot VM中，每个JVM线程都和一个操作系统本地线程直接映射。当一个Java线程创建好准备运行时，此时一个操作系统的线程也同时创建。Java线程终止后，操作系统线程也会回收。

​	操作系统负责所有线程的安排调度。会将线程安排到可用的CPU上。一旦本地线程创建好，就会调用Java线程中的`run()`方法。

### 后台线程

​	如果使用调试工具，可以看到除了Java应用程序自己编写的线程外(调用main方法的线程和main线程自己创建的线程)，后台还有很多线程在执行。这些后台系统线程主要包含以下几个：

- 虚拟机线程：这种线程的操作需要JVM达到安全点才会出现。该线程的执行类型包括"stop-the-world"垃圾回收、线程栈回收、线程挂起以及偏向锁撤销。
- 周期任务线程：这种线程是时间周期事件的体现，如中断。一般用于周期性操作的调度执行。
- GC线程：这种线程对JVM里不同种类的垃圾回收提供支持。
- 编译线程：在运行时将字节码转换为本地代码。
- 信号调度线程：接收信号并发送给JVM，在它内部调用适当的方法进行处理。



# 程序计数器

## 程序计数器介绍

​	JVM中的程序计数器，其命名源于CPU中的PC寄存器，在CPU中用于记录下一条指令的地址。JVM中的程序计数器是对物理PC寄存器的抽象模拟。也是存储下一条指令的地址，由执行引擎负责读取下一条指令。

​	PC是一块很小的内存空间，是运行速度最快的内存空间。每个线程都有自己的PC，即PC为线程私有，生命周期与线程周期保持一致。

​	任何时刻，一个线程只会有一个方法在执行，也就是所谓的*当前方法*。PC会记录当前方法的JVM指令地址。如果在执行的是native方法，PC内容为未指定值(undefined)。

​	PC是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个寄存器。字节码解释器就是通过修改PC的内容来获取下一条需要执行的字节码指令。同时，PC也是JVM规范中唯一没有规定任何OOM的区域。



## 常见问题

### 使用PC寄存器存储字节码指令地址有什么用？为什么使用PC寄存器记录当前线程的执行地址呢？

​	在CPU中，因为CPU需要不停的切换各个线程，当切换回来以后，CPU需要知道从哪里开始执行。JVM的字节码解释同样也是如此，通过PC寄存器来指明下一条需要执行的指令。

### PC寄存器为什么是线程私有

​	为了能够准确记录每个线程正在执行的字节码指令地址。还是因为会有线程切换。

​	CPU采取的是时间片轮转，CPU或者多核CPU的每个核心，每个时刻只会执行一个线程的一条指令，总是会频繁的切换线程。



# 虚拟机栈

## 概述

​	Java的指令是基于栈来实现的，优点是可以跨平台，指令集小，编译器容易实现。缺点是，性能下降，实现同样的功能需要更多指令。

​	栈是运行时的单位，而堆是存储的单位。即，栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题,即数据怎么放、放在哪儿。

​	Java虚拟机栈，每个线程创建时都会创建一个虚拟机栈，内部保存一个一个的栈帧，对应每次的方法调用。因此，生命周期和线程一致。保存方法的局部变量、部分结果，并参与方法的调用与返回。

## 栈的存储单位



## 局部变量表



## 操作数栈



## 代码追踪



## 栈顶缓存技术



## 动态链接



## 方法的调用：解析与分派



## 方法返回地址



## 附加信息



## 面试题





