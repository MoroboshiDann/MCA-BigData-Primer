# 前端

## JS对象

### JSON

- JavaScript Object Notation，JavaScript对象标记法

- 结构简单，层次分明，多用于**数据载体**，在网络中传输数据

- 以键值对形式定义

- ```javascript
  {"key1": "value1", "key2": "value2", "addr1": ["value1", "value2"]}
  ```

### DOM

- Brower Object Model，浏览器对象模型，允许JavaScript与浏览器对话，JavaScript将浏览器各个部分分装成对象

- 组成：

  - Window：浏览器窗口对象

    - 获取：直接使用window，其中`window.`可以省略，如`window.alert("hello world")` `alert("hello world")`

    - 属性：

      - `history`：对`History`对象的**只读**引用
      - `ocation`：对窗口或框架的`Location`对象
      - `navigato`r：对`Navigator`对象的**只读**引用

    - 方法：

      - `alert()`：显示带有一个消息和一个确认按钮的警告框

      - `confirm()`：显示带有一个消息和一个确认与取消按钮的对话框。返回值为`boolean`

      - `setInterval()`：按照指定的周期(单位为毫秒)来调用函数或计算表达式

        - ```javascript
          setInterval(function() {
              i++;
              console.log("program has executed this" + i + "time");
          }, 2000);
          ```

      - `setTimeout()`：在指定的毫秒数之后调用函数或计算表达式

        - ```javascript
          setTimeout(function() {
              alert("alert");
          }, 2000)
          ```

  - Navigator：浏览器对象

  - Screen：屏幕对象

  - History：历史记录对象

  - Location：地址栏对象

    - `alert(location.href)` `location.href="https://github.com"`

### DOM

- Document Object Model，文档对象模型，JavaScript将标记语言的各个部分封装成为对象
- 组成：
  - `Document`：整个文档对象
  - `Element`：元素对象
  - `Attribute`：属性对象
  - `Text`：文本对象
  - `Comment`：注释对象
- JavaScript通过DOM可以对HTML进行操作：
  - 改变元素内容
  - 改变元素样式
  - 对HTML DOM事件做出反应
  - 添加和删除HTML元素

## JS事件

### 事件监听

- 事件：HTML事件发生在HTML元素上的事情，如按钮被点击，鼠标移动到元素上，按下键盘按键
- 事件监听：JavaScript可以在事件被侦测到时**执行代码**

## Ajax

- Asynchronous JavaScript And XML，异步的JavaScript和XML
- 作用：
  - 数据交换：通过Ajax可以给服务器发送请求，并获取服务器响应的数据
  - 异步交换：可以在**不重新加载整个页面**的情况下，与服务器交换数据并更新部分网页的技术



## Maven

### 依赖配置

- 在`pom.xml`文件中，添加`<dependencies></dependencies>`标签
- 添加完成后，需要点击重新加载才能生效
- 如果maven仓库中已经有该依赖，键入时会有提示

## 依赖传递

- 依赖具有传递性，如果A依赖B，B依赖于C，则A只需要导入它的直接依赖B![image-20231208182518552](D:\MyRepository\gitRepository\MoroboshiDan\JavaWeb\img\依赖传递-1.png)
- 如果A不需要依赖B的依赖，可以通过`<exclusions></exclusions>`标签来排除不需要的资源，不需要指定版本

## 依赖范围

- 默认情况下，依赖的jar包可以在任何地方使用，如main和test文件夹中，可以通过`<scope></scope>`标签来设置作用范围![image-20231208183335268](D:\MyRepository\gitRepository\MoroboshiDan\JavaWeb\img\依赖范围-1.png)

## 生命周期

maven的生命周期就是为了对所有的maven项目构建过程进行抽象和统一

maven中有三套相互独立的生命周期

- clean：清理工作。清理上次编译产生的文件，如.class字节码文件
  - pre-clean
  - clean：移除上一次构建生成的文件
  - post-clean
- default：核心工作。如编译、测试、打包、安装、部署等
  - complie：编译项目源代码
  - test：使用合适的单元测试框架运行测试(junit)
  - package：将编译后的文件打包，如：jar，war
  - install：安装项目到本地仓库
- site：生成报告、发布站点等

在同一套生命周期中，运行后面的阶段，前面的阶段也会先运行



# HTTP

## 概述

Hyper Text Transfer Protocol，超文本传输协议，

- 基于TCP协议：面向连接，安全
- 基于请求-响应模型的：一次请求对应一次响应
- HTTP协议时**无状态**的协议：对事物的处理没有记忆能力，每次请求-响应都是独立的
  - 缺点：多次请求间不能共享数据
  - 优点：速度快

## 请求协议

请求格式：

- 请求行：请求数据第一行，包含请求方式、资源路径、协议等
- 请求头：请求数据第二行开始，格式为`key, value`![image-20231208200032591](D:\MyRepository\gitRepository\MoroboshiDan\JavaWeb\img\http请求头.png)
- 请求体：POST请求，存放请求参数，为json格式
  - GET请求，请求参数在请求行中，没有请求体。GET请求的大小是有限制的
  - POST请求，请求参数在请求体中，请求的大小有没限制

## 响应协议

响应格式：

- 响应行：响应数据第一行，包含协议、状态码和描述
- 响应头：第二行开始，格式为`key, value`![image-20231208201709568](D:\MyRepository\gitRepository\MoroboshiDan\JavaWeb\img\http响应头.png)
- 响应体：最后一部分，存放响应数据

## 常见响应状态码

![image-20231208202132649](D:\MyRepository\gitRepository\MoroboshiDan\JavaWeb\img\statusCode.png)

## HTTP响应解析

**详情请见黑马程序员JavaWeb2023 Day04-14**

在`Server`类中创建`handle(InputStream input, OutputStream output)`方法，先对输入输出流包装，然后解析请求行，确认请求类型和协议类型，然后进行相应响应，最后再判断响应执行情况，如果执行成功，写响应报文

# Tomcat

- 概念：Tomcat是Apache软件基金会的一个核心项目，是一个开源免费的轻量级web服务器，支持Servlet/JSP少量JavaEE规范
- Tomcat也被称为Web容器、Servlet容器，Servlet程序需要依赖于Tomcat才能运行

- 运行之后，会在计算机的8080端口运行一个web服务器，访问该端口是在访问tomcat主路径下的webapps文件夹中已经部署的项目

- 基于SpringBoot开发的web程序，内置了tomcat服务器，运行启动类会自动启动内嵌的tomcat服务器

# 请求响应

- 前置控制器DispatccherServlet，接受tomcat服务器收到的请求，然后进行解析，发送给各个controller

![image-20231208202132649](D:\MyRepository\gitRepository\MoroboshiDan\JavaWeb\img\dispatcher.png)

## 请求响应

- 请求(HttpServletRequest)：获取请求数据

- 响应(HttpServletResponse)：设置响应数据

- BS架构：Brower/Server，浏览器/服务器架构模式，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端

- CS架构：Client/Server，客户端/服务器架构模式


## 请求参数获取

### 简单参数

- 原始方式：在controller对应的方法中，使用`HttpServletRequest`对象来接受传入的参数
  - 该对象中的`parameter`都是以字符串形式存储的，需要进行解析
- SpringBoot方式：直接在方法的传入参数中使用与请求参数同名形参即可
  - 可以进行自动的类型转换，不需要将字符串解析
  - 无论是POST请求还是GET请求，都可以直接获取，只需要保证变量名一致
  - 如果参数名不一致，会导致无法接收，对应变量值为null
  - 通过添加`@RequestParam(name = "var" String uservar)`注解，即可完成映射，让uservar接收前端传入的var
    - 该注解中的`required`属性默认为`true`，代表该参数必须传递，如果前端没有传递，会报错



### 实体参数

- 简单实体对象：请求参数与形参对象属性名相同，定义POJO接收即可
  - 前端传递参数过多，可以将它们全部封装到一个实体类中，然后使用该实体类接收
- 复杂实体对象：当封装的实体对象中含有成员对象，同样保持请求参数名与形参对象属性相同即可，会按照层次结构关系接收嵌套属性参数
  - 前端传递时，属性名需要是嵌套的`address.province`

```java
// 前端json
{
    name: "Tom",
    age: "10",
    address.province: "Beijing",
    address.city: "Beijing"
}
// 后端
@GetMapping("/complexPojo")
public String complexPojo(User user) {
    sout.(user); return "OK";
}
public class User {
    String name;
    int age;
    Address address;
}
public class Address {
	String province;
    String city;
}
```

- 如果是POST请求，请求参数会在请求体中的Param中，也可以直接接收

### 数组集合参数

- 数组参数：请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可正确接收
  - e.g. 请求为`GET https:/localhost:8080/arrayParam?hobby=game&hobby=java`，同一请求参数名有多个参数
  - 集合参数：请求参数名与形参集合名称相同且请求参数为多个，使用`@RequestParam`绑定关系

```java
@GetMapping("/listParam")
public String listParam(@RequestParam List<String> hobby) { sout.(hobby); return "OK";}
```

### 日期参数

- 使用`@DateTimeFormat(patter = "yyyy-MM-dd HH:mm:ss")`来完成日期参数格式转换，且请求参数名与形参名要保持一致，使用`LocalDateTime`对象来接收

### JSON参数

- JSON数据键名与形参对象属性名相同，定义pojo类即可接收，需要`@RequestBody`来注解

### 路径参数

- 通过URL直接传递参数，参数就是请求路径的一部分，使用`@PathVariable`来接收，如果与形参名不一致，可以通过在注解后面添加`("var")`的形式来指定
- 路径中参数部分，不能写死，需要使用`{id}`花括号来括起来



## 响应数据

### @ResponseBody

- 方法注解、类注解
- 位置：Controller方法上和类上
- 作用：将方法返回值直接相应，如果返回值类型是 实体对象/集合，将会转换为JSON格式响应
- 说明：@RestController = @Controller + @ResponseBody

### 返回结果

- 为了统一返回给前端的结果，通常将结果分装为`Result`类，一般包含`code, msg, data`三个部分，以及一些静态方法方便使用。`Object data`部分用于存储返回的数据



# 分层解耦

## 三层架构

- Controller：控制层，接收请求，响应数据
- Service：业务逻辑层，处理具体的业务逻辑
- Dao(Mapper)：数据访问层(Data Access Object)(持久层)，负责数据访问操作，包括数据的增删改查

## 解耦

- 内聚：软件中各个功能模块内部的功能联系
- 耦合：衡量软件中各个层/模块之间的依赖、关联的程度

高内聚，低耦合。修改一层的代码，不会影响到其他层的使用

Spring提供的@AutoWired可以解决耦合问题，自动注入对象

- 将接口的实现类对象交给容器管理，当使用到该接口的对象时，从容其中自动注入对象

## IOC&DI

- 控制反转：Inversion Of Control，对象的创建控制权由程序自身转移到外部(容器)，这种思想称之为控制反转
- 依赖注入：Dependency Injection，容器为应用程序提供运行时所依赖的资源，称之为依赖注入
- Bean对象：IOC容器中创建、管理的对象，称之为bean

> 控制反转是Spring框架的第一大特性，将程序所需要的资源的创建权交给程序之外的容器来管理
>
> 程序使用资源时不能直接`new`出来，需要让容器为其提供
>
> 容器成为IOC容器

### 入门

- Service层及Dao层的实现类，交给IOC容器管理，使用`@Component`注解
  - 有多个实现类时，需要哪个就给哪个实现类标上@Component注解
- 为Controller及Service注入运行时，依赖的对象

### IOC详解

![image-20231209162950934](D:\MyRepository\gitRepository\MoroboshiDan\JavaWeb\img\IOCNotation.png)

- 通常在Service实现类上标注@Service注解

Bean组件扫描

- 前面声明bean的四大注解想要生效吗，需要被组件扫描注解@ComponentScan扫描
- @ComponentScan注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解@SpringBootApplication中，默认的扫描范围是启动类所在包及其子包

### DI详解

- @Autowired注解，默认是按照类型进行的，如果存在多个相同的bean，会报错。即同一个接口的实现类不能同时存在于容器中
- 解决方案
  - @Primary，在实现类上额外注解
  - @Qualifier，在@Autowired上面额外注解，使用`value = "ImplName"`来指定生效的bean
  - @Resource，由jdk提供的注解，替换@Autowired。默认按照名称进行注入，而前者是按照类型注入

```java
@Resource(name = "ImplName")
private EmpService empService;
```





# MySQL

## DDL

### 创建表

```sql
create table charactor {
	id int primary key comment auto_increment 'ID 唯一标识',
	username varchar(20) not null unique comment '用户名',
	name varchar(10) comment '姓名',
	age int comment '年龄',
	gender varchar(7) default 'male' comment '性别'
} comment '用户表'
create table table_name {
	field_1 category [limit] [comment ],
	...
} [comment ]
```

## 索引

- 通常为B+树结构
- MySQL会为主键自动建立索引
- 唯一索引：指数据中不会出现重复值

# Mybatis

## 使用步骤

- 准备工作：创建SpringBoot工程，数据库表user，实体类User
- 引入Mybatis相关依赖，配置Mybatis(数据库连接信息)
- 编写SQL语句(注解/XML)

> MyBatis是在Spring框架中的持久层(Dao/Mapper)起作用的，具体做法为，给Mapper接口中定义数据库增删改查方法，然后使用注解或者绑定XML文件的方式，将方法与对应SQL语句绑定起来，便可通过注入Mapper接口对象的方式直接使用该方法

- 如果书写sql语句时，没有自动补全提示，需要注入语言信息
- 如果书写表名的时候没有提示，是因为idea没有和数据库建立连接



## JDBC

- SUN公司提供标准，具体数据库厂商提供实现

```java
// 注册驱动
// 获取执行SQL的对象，执行SQL
// 解析查询结果，封装到对应类中
// 释放连接资源
```

- 存在：硬编码(驱动信息是写死的)、操作繁琐(需要一个字段一个字段地解析结果)、资源浪费性能低(频繁获取连接释放连接)

> MyBatis中，将数据路连接信息配置在.yml/properties中，不需要修改代码便可以修改连接信息
>
> 自动将查询结果封装到对应的对象中去
>
> spring.datasource会自动使用数据库连接池技术统一管理数据库连接Connection对象，使用Mapper接口中的方法时自动分配连接对象，查询完成后自动归还，避免了重复创建连接的性能损失

 ## 数据库连接池

- 是一个容器，负责分配、管理数据库连接(Connection)
- 它允许应用程序使用一个现有的数据库连接，而不是重新建立一个
- 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏

- 优势：
  - 资源重用
  - 提升响应速度(不用重新创建链接)
  - 避免数据库连接遗漏



- 标准接口：DataSource
  - 官方提供的数据库连接池接口，由第三方数据库实现该接口
  - 功能：获取链接 `Connection getConnection() throws SQLException;`
- 常见产品：
  - Hikari：SpringBoot默认，如果不指定连接池，默认使用该连接池
  - Druid：Alibaba开源数据库连接池项目，功能强大，性能优秀，是Java语言最好的连接池之一

### Druid数据库连接池

- 启动依赖

```java
<dependency>
	<groudId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.2.8</version>
</dependency>
```



## 基础操作

- MySQL占位符`#{}`，只需要传入参数名和占位符中的名称一致即可自动传入
- SQL语句运行时，会自动使用参数替换占位符

## 预编译SQL

- 性能高：如果将属性写死，每次执行都需要进行解析、优化、编译这几个步骤。只需要编译一次
- 更安全(防止SQL注入)：
  - SQL注入是通过操作输入的数据来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法
  - 例如，登录时，密码输入为`'or '1' = '1`，即可使SQL语句拼接为`select from user where id = 'id' and password = '' or '1' = '1'`，实现登录

### 删除操作

```java
@Delete("delete from user where id = #{id}")
public int delete(Integer id);
```

- SQL语句返回值为此次操作影响的记录数量

## XML映射文件

- XML映射文件的名称与Mapper接口名称一致，并将XML映射文件和接口文件放置在同一包下(一般在resources下，同包同名)
- XML映射文件的namespace属性为Mapper接口全限定名一致
- XML映射文件中SQL语句的id与Mapper接口中的方法名一致，并保持返回类型一致

> 使用XML文件来书写SQL语句，执行到Mapper接口中的方法时，MyBatis会自动寻找与Mapper同包同名的XML文件，并找到与方法名一致的SQL语句去执行

## 动态SQL

- 随着用户的输入或外部条件的变化而变化的SQL语句

### <if>

- 用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL

```xml
<where>
<if test = "name != null">
	name like concat('%', #{name}, '%')
</if>
<if test = "begin != null and end != null">and entrydate between #{begin} and #{end}</if>
</where>
```

- 使用<where>包裹所有的判断，如果有<if>成立，才会在SQL语句中生成`where`
- 会自动去除条件前面的`and`

### <foreach>

用来遍历集合中的元素，因为集合的长度不固定，不能用固定的SQL来书写，需要根据传入的数据来拼接SQL语句

- collection：要遍历的集合，通常为Mapper接口定义的方法的形参名
- item：遍历出来的元素，自己定义，后面的占位符中填写此名称
- separator：分隔符，给SQL语句中拼接的分隔符
- open：遍历开始前拼接的SQL片段
- close：遍历结束后拼接的SQL片段

```xml
<!-- 传入的为18，19，20 -->
<delete id = "deleteByIds">
	delete from user where id in
    <foreach collection = "ids" item = "id" separator = "," open = "(" close = ")">
    #{id}
    </foreach>
</delete>
```

### <sql><include>

- SQL语句如果写死，后期表明发生变化，或者属性名发生变化，就需要修改每一个方法对应的语句，现在将语句主体抽取出来，放在<sql>标签中，然后在方法中使用<include>标签来调用

```xml
<sql id = "commonSelect"> select id, username, password, gender from user </sql>
<include refid = "commonSelect"/>
```

# SpringBoot开发案例

## 分页查询

### MySQL分页查询语法

select * from emp limit 0, 5；

第一个参数：起始索引，从当前表的第几条记录开始查询

第二个参数：查询返回的记录数

用于获取总记录数：`select count(*) from emp`

前端需要传递给后端的参数：当前页码page，每页展示记录数pageSize

后端需要给前端返回的数据：总数据列表List，总记录数total

使用实体类`PageBean`封装结果

### 手动实现

```java
@Mapper
public interface EmpMapper {
  @Select("select count(*) from emp")
  public Long count();
  @Select("select * from emp limit #{start}, #{pageSize}")
  public List<Emp> page(Integer start, Integer pageSize);
}
@RestController
public class EmpController {
  @GetMapping("/emps")
  public Result<PageBean> page(@RequestParam(defaultValue = "1") Integer page, @RequestParam(defaultValue = "10") Integer pageSize) {
    PageBean pageBean = empService.page(page, pageSize);
    return Result.success(pageBean);
  }
}
@Service
public class EmpServiceImpl implements EmpService {
  @Autowired
  private EmpMapper empMapper;
  PageBean page(Integer page, Integer pageSize) {
    Integer total = empMapper.count();
    Integer start = (page - 1) * pageSize;
    List<Emp> empList = empMapper.page(start, pageSize);
    return new PageBean(total, empList);
  }
}
```

### PageHelper分页插件

- 手动实现存在缺点：步骤固定，实现繁琐

```java
// Mapper文件中，正常执行查询操作即可
@Select("select * from emp")
public List<Emp> list();
// 在使用时，使用startPage方法指定分页参数
public PageBean page(Integer page, Integer pageSize) {
  PageHelper.startPage(page, pageSize);
  List<Emp> empList = empMapper.list();
  Page<Emp> page = (Page<Emp>)empList;
  PageBean pageBean = new PageBean(p.getTotal(), p.getResult());
  return pageBean;
}
```

### 附带条件的分页查询

- 如果是在搜索框中搜索某个员工，还需要传递相关的信息

- 只需要正常进行条件查询，就可以实现分页条件查询

## 配置文件

- 将需要的属性写入yml文件中后，只需要创建一个属性包装类，使用`@ConfiguriationProperties(prefix="aliyun.oss")`注解，即可自动填充属性
- 需要保证变量名一致

# 登录校验

- 浏览器端每次发送请求，都要检查是否已经登录，如果已经登录则允许访问，否则跳转至登陆界面
- 使用统一拦截方法，登陆成功后，记录登录标记

## 会话技术

- 浏览器与服务器之间的连接称为会话
- 用户打开浏览器，访问web服务器的资源，建立会话，直到有一方断开连接，会话结束。一次会话中可以**包含多次**请求响应
- 会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便于在同一次绘画的多次请求间**共享数据**
  - 客户端会话跟踪技术：Cookie
  - 服务端会话跟踪技术：Session
  - 令牌技术

### Cookie

- 在浏览器第一次请求的时候，创建Cookie，保存用户信息
- 服务端响应数据时，自动将Cookie返回给浏览器
- 浏览器接收到Cookie后，自动将其存储到本地，以后每次请求该网站都会自动将Cookie发送给服务器端

优点：

- HTTP协议中支持的技术

缺点：

- 移动端APP无法使用Cookie
- 不安全，用户可以自己禁用Cookie
- Cookie不能跨域
  - 前后端分离的程序，前后端部署在不同服务器上
  - 访问前端和后端的IP地址和端口号都不一致(协议、IP/域名、端口有一个不一致的就是跨域)
  - 此时Cookie无法使用

### Session

- 使用HttpSession对象来获取和使用Session

原理：

- 客户端发送请求，如果有JSESSIONID就携带
- 如果客户端携带了JSESSIONID，先判断这个id对应的session是否存在，如果存在直接返回session，如果不存在就创建该session，并以Cookie的形式返回JSESSIONID
- 如果客户端没有携带JSESSIONID的Cookie，直接创建新的session并返回，同时以Cookie的形式返回JSESSIONID

优点：

- 存储在服务端，安全

缺点：

- 服务端通常为分布式集群，集群环境下无法直接使用Session
- Cookie的缺点

### 令牌技术

- 用户登陆成功时，生成一个JWT令牌，令牌是用户的合法身份认证
- 响应数据时将令牌返回给浏览器，浏览器进行存储
- 以后每次发起请求就将令牌携带至后端，后端校验成功后执行请求
- 如果同一个浏览器的多次会话之间想共享数据，可以将信息存储在令牌中

优点：

- 支持PC端和移动端
- 解决集群环境下的认证问题
- 减轻服务器端存储压力

缺点：

- 需要手动实现

# JWT令牌

- JSON Web Token
- 定义了一种简洁的、自包含的格式，用于通信双方以JSON数据格式安全的传输信息。由于数字签名的存在，这些信息是可信的
  - 本身就是一个字符串，可以在请求参数或者请求头中携带令牌
  - 可以在JWT令牌中存储用户信息
- 组成：
  - Header：记录令牌类型，签名算法等
  - Payload：携带一些自定义信息，默认信息等
  - Signature：防止Token被篡改，确保安全性。将Header，Payload加入指定密钥，通过指定签名算法计算而来

> 前两部分是将该部分原始信息进行**BASE64**编码而来的

## 使用

- 引入JWT依赖
- 使用`Jwts.builder()`来生成一个JWT对象
  - `signWith(SignatureAlgorithm sa, String secretKey)`用于指定签名算法和密钥
  - `setClaims(Map<String, Object> map)`用于将用户信息存储在Payload中
  - `setExpiration(Date date)`设置有效期，通常为`new Date(System.currentTimeMillis() + 3600*1000)`，一小时有效期
  - `compact()`获得String类型的返回值
- 服务端每次接收到请求时，都要进行令牌解析，并进行校验
  - 使用HttpServletRequest对象来获取请求头，从中解析出JWT

## Filter

- 过滤器，是JavaWeb三大组件之一(Servlet, Filter, Listener)
- 可以将对资源的请求拦截下来，从而实现一些特殊的功能
- 过滤器一般完成一些通用的操作，如：登录校验、统一编码处理、敏感字符处理等

使用：

- 定义Filter类：定义一个类，实现Filter接口，重写其所有方法(最主要的是doFilter)
  - init初始化方法只会在启动时执行一次
- 配置Filter：给Filter类上加@WebFilter注解，配置拦截资源的路径，引导类上加@ServletComponentScan注解开启Servlet组件支持

执行流程：

- 浏览器请求资源时，执行重写的doFilter方法
  - 放行前逻辑
  - 执行FiterChain.doFilter()方法，执行放行操作(**资源访问完之后，还会回到Filter中)
  - 放行后逻辑

过滤器链：

- 一个web应用中，可以配置多个过滤器，会依次执行
- 执行完所有拦截器才会访问到资源，访问完之后还会依次返回，执行拦截后逻辑

> 注解配置的Filter，优先级是按照过滤器类名的自然排序


## Interceptor

### 简介

- 一种动态拦截方法调用的机制，类似于过滤器。Spring框架中提供的，用来动态拦截Controller方法的执行
- 作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定好的代码

### 使用步骤

- 定义拦截器，实现handlerInterceptor接口，并重写其所有方法
- 注册拦截器

> 三个方法
> `public boolean preHandler()`目标资源方法执行前执行，返回true放行，返回false不放行
> `public void postHandler()`目标资源方法执行后执行
> `afterCompletion()`视图渲染完毕后执行，最后执行


# 异常处理

- 程序开发中不可避免的异常现象
- 如果后端不处理，返回给前端的信息无法被正常解析
  - 如果未作处理，出现异常时就会逐层回抛，如：Mapper出现了异常，传给Service，然后传给Controller

处理方法：

- 在Controller方法中使用`try catch`将所有会出现异常的代码环绕起来
  - 简单，但操作繁琐，每个controller方法都需要操作，代码臃肿
- 全局异常处理器
  - 简单，优雅，推荐

## 全局异常处理器

- 出现异常时由全局异常处理器捕获，处理后返回给前端结果

使用方法：

- 全局异常处理器上标注@RestControllerAdvice
- 异常处理方法上标注@ExceptionHandler，可以在其后将异常的.class文件传入，以指定处理的异常种类
  - 方法的形参为对应异常的对象


# 事务管理

## 事务基础

概念：

- 事务是一组操作的集合，是一个不分割的工作单位，**要么同时成功，要么同时失败**

## 性质

- 原子性(Atomicity)：事务是一个不可分割的单位，其中的操作要么全部完成，要么全部失败
- 一致性(Consistency)：事务的操作，必须使数据库从一个一致性状态变换到另一个一致性状态(可以理解为正确状态)
- 隔离性(Isolation)：多个用户并发访问数据库时，每个用户的事物之间不会相互影响。
- 持久性(Durability)：一个事务一旦提交，它对数据库的更改就是永久的，数据库之后发生的故障不会对其产生影响

## 事务的并发问题

- 脏读(Dirty Read)：一个事务对数据进行了修改，但是还没有提交，另一个事务读取了该数据
- 不可重复读(Unrepeatable Read)：一个事务内，多次读取同一个数据，在事务没有结束前，该数据的值不会发生变化
- 幻读(Phantom Read)：类似于不可重复读

操作：

- 开启事务(一组操作开始前，开启事务)：start transaction / begin;
- 提交事务(改组操作全部完成后，提交事务)：commit;
- 回滚事务(中间任何一个操作出现异常，回滚事务):rollback;

通常使用@Transactional注解，将事务的控制交给Spring来管理，出现异常自动回滚

- 标注在接口上，表示实现该接口的所有类都受Spring管理
- 标注在实现类上，表示该实现类受Spring管理
- 标注在方法上，表示该方法的事务受Spring管理，推荐

## 事务的隔离级别

- Read Uncommited：事务可以读取其他未提交事务的数据
- Read Commited：事务需要等到其他事务提交之后才能读取它的数据
- Repeatable Read：开始取数据时，不允许修改操作
- Serializable：事务隔离的最高级别，事务串行进行

## rollbackFor

e.g.

```java
@Transactional
public void delete(Integer id) throws Exception {
    deptMapper.deleteById(id);
    if (true) {
        throw new Exception();
    }
    empMapper.deleteByDeptId(id);
}
```

以上实例中，删除员工数据的代码不会执行，但是事务还是会成功提交

- 默认情况下，只有出现RuntimeException才会回滚。rollbackFor属性用于控制出现何种异常类型，回滚事务。
  - 使用`@Transactional(rollbackFor = Exception.class)`，方法中出现所有的异常都会回滚，就能恢复正常

## propagation

- 事务传播行为：指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制
  - e.g. A，B方法标注了@Transactional，A调用了B方法，A执行时会开启事务，执行B时是开启新事务还是加入A的事务

使用方法：

- Propagation.REQUIRED：默认值，需要事务，有则加入，无则创建新事务
- Propagation.REQUIRES_NEW：需要新事务，无论有无，总是创建新事务

# AOP

- AOP：Aspect Oriented Programming，面向切面编程、面向方面编程。**其实就是面向特定方法编程**
- 是一种编程思想

e.g.

- 如果想统计多个方法的耗时，普通做法是在每个方法开始前记录时间，方法执行完成后就时间并计算耗时
- AOP，将公共部分抽取出来，定义为模板方法。可以在不修改原始业务代码的前提下，实现新的功能

实现：

- 动态代理是面向切面编程最主流的实现。而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程
- 动态代理是AOP的最主要的实现

场景：

- 记录操作日志
- 权限控制
- 事务管理
  - @Transactional注解底层就是动态代理实现的，在原始方法开始之前开启事务，在原始方法结束之后提交或回滚事务

## 核心概念

- 连接点：JoinPoint，即可以被AOP控制的方法
- 通知：Advice，指那些重复的逻辑，即共性功能
- 切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法被执行时被应用。@Around()
- 切面：Aspect，描述通知与切入点的对应关系
- 目标对象：Target，通知所应用的对象

## 执行流程

使用AOP之后，程序运行时会自动为目标对象生成一个代理对象，代理对象中会对目标对象的原始方法进行增强，会按照切面中定义的方法进行执行

## 通知类型

即切面中定义的方法的类型

- @Around：环绕通知，此注解标注的通知方法在目标方法执行前、后都被执行
- @Before：前置通知，通知方法只在目标方法执行前执行
- @After：后置通知，目标方法执行后执行，无论是否出现异常，都会被执行
- @AfterReturning：返回后通知，通知方法在目标方法正常执行后被执行，有异常不会执行
- @AfterThrowing：异常后通知，通知方法在发生异常后执行

# Builder建造者模式

`builder()`的使用方法 

- 给实体类添加一个Builder私有静态成员类，里面提供静态方法，将赋值操作封装，然后返回this

- 或者使用Lombok提供的@Builder注解



# Servlet

## HTTP

Hyper Text Transfer Protocol，超文本传输协议。

是客户端和服务端之间进行通信的协议，能够屏蔽掉浏览器的差异，只关心通信本身。

> 当webserver拥有了动态生成页面的applet程序的能力时，可以将webserver变为容器，按照需求返回动态的页面，称为servlet。基于HTTP的服务端生成页面的程序
>
> 后来演变出可以在Java代码中嵌入页面标签的技术，称为jsp(java server page)
>
> 该技术后来演变为高级框架ssm

特点：

- 基于TCP协议：面向连接，安全
- 基于请求-响应模型的：一次请求对应一次响应
- HTTP协议时**无状态**的协议：对事物的处理没有记忆能力，每次请求-响应都是独立的
  - 缺点：多次请求间不能共享数据
  - 优点：速度快

### HTTP交互过程详解

- 建立连接：虽然HTTP是面向无连接的，但是其是基于TCP协议的，需要先建立TCP连接，三次握手。
- 发送请求：客户端发送HTTP请求
- 返回响应：服务器对客户端的请求做出响应
- 关闭连接：通过四次挥手断开TCP连接



## Tomcat

客户端和服务器之间是通过IO流来传输数据的，先建立TCP连接，然后根据HTTP协议通信。

在服务器端运行的是webserver程序，如Tomcat。



## Servlet的使用

- 创建Java类，继承HttpServlet类
- 重写service方法
  - 如果对于各种请求的响应方式有变化，也可重写
- 在WEB-INF下的web.xml文件中添加请求与servlet类的映射关系



## 访问流程

浏览器发送请求到服务器，服务器根据请求的url地址中的uri信息在webapps目录下找到对应的项目文件夹，然后在web.xml文件中检索对应的servlet，找到后调用执行
