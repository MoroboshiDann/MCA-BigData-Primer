# 贪心算法

## 什么是贪心算法

​		每个阶段都取得局部最优解，最终取得了全局最优解。

## 贪心的套路

​		贪心无套路。

​		先想出局部最优的解法，而且这个局部最优的方法没有反例，就可以尝试贪心算法。

## 例题

### 1. 分发饼干

#### 问题描述

​		两个数组，一个数组表示每个小孩子的胃口，另一个数组表示每个饼干的规格。问怎么样分发饼干能够满足最多的小孩。

#### 思路分析

​		对于每个饼干来说，尽量分发给胃口最大的小孩，这样能够最大限度利用饼干的规格。所以，每拿到一个饼干，去找它能满足的胃口最大的小孩。

​		则首先，应该对两个数组排序，然后遍历饼干数组，对于每个饼干，逆序遍历胃口数组，如果能够满足则结束内层遍历，否则继续。对于已经满足的小孩，应当作出标记。

```java
public class Solution {
    public int maxSatisfied(int[] appetite, int[] scale) {
        Arrays.sort(appetite);
        Arrays.sort(scale);
        int ans = 0;
        int index = appetite.length;
        for (int i = scale.length - 1; i >= 0; i--) {
            while (index >= 0 && appetite[index] > scale[i]) {
                index--;
            }
            if (index < 0) break;
            ans++;
        }
        return ans;
    }
}
```



# 动态规划

## 状态转移方程

​		描述问题结构的数学公式。如斐波那契数列问题中，元素值与元素索引的关系为：
$$
f(n) =  1 , n = 1, 2 \\
f(n) = f(n - 1) + f(n - 2), n > 2
$$
​		其中，n就是状态，从0一直变化至n。

## 解题步骤

​		以凑零钱问题为例，展示解题步骤。

> 题目描述：
>
> ​		给你 `k` 种面值的硬币，面值分别为 `c1, c2 ... ck`，每种硬币的数量无限，再给一个总金额 `amount`，问你**最少**需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。

​		首先，对于动态规划问题，要先找到暴力解，然后再进行优化。

​		对于动态规划问题，需要具有**最优子结构**。符合**最优子结构**，子问题之间需要相互独立。

​		而对于本题，零钱数量是无限的，所以，子问题之间没有任何制约。想要求`amount = 11`的问题，只需要知道如何凑出`amount = 10 `就可以直接将子问题的答案加1即可。



### 1. 确定base case

​		即当n=0时，方法的返回值为多少

### 2. 确定状态

​		状态，**也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。

### 3. 确定选择

​		**也就是导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

### 4. 明确`dp`函数/数组的定义

​		我们这里讲的是自顶向下的解法，所以会有一个递归的 `dp` 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。

​		**所以我们可以这样定义 `dp` 函数：`dp(n)` 表示，输入一个目标金额 `n`，返回凑出目标金额 `n` 所需的最少硬币数量**。



​		基于以上分析，可以先将题解的伪代码列出：

```java
int coinChange(int[] coins, int amount) {
	// 题目要求的最终结果的状态是，n = amount
    return dp(coins, amount);
}
int dp(int[] coins, int n) {
    // 做选择，原则需要硬币数量最小的结果
    for (int coin : coins) {
        ans = min(ans, 1 + dp(coins, n - coin));
    }
    return ans;
}
```

​		根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：

```java
int coinChange(int[] coins, int amount) {
    return dp(coins, amount);
}
int dp(int[] coins, int n) {
    if (n == 0) return 0;
    if (n < 0) return -1; // 无解
    int ans = Integer.MAX_VALUE;
    for (int coin : coins) {
        int subProblem = dp(coins, amount - coin);
        if (subProblem == -1) continue; // 子问题无解，跳过这个子问题
        ans = Math.min(ans, subProblem + 1);
    }
    return ans == Integer.MAX_VALUE ? -1 : ans;
}
```

​		至此，可以列出状态转移方程
$$
f(n) = \left\{
\begin{aligned}
0 & , & n = 0;\\
-1 & , & n < 0;\\
min(f(n - coin) + 1 | coin \in coins), n > 0;
\end{aligned}
\right.
$$

## 优化

### 1. 带备忘录的递归

​		经过上述分析，已经可以通过暴力递归来将问题解决了，我们可以画出递归树，看到重叠子问题。

然后结合之前斐波那契的例子，就可先通过带备忘录的递归来进行优化。

> 画出递归树，可以观察到，有很多子问题是被重复计算的。而如果我们添加一个备忘录，用来记录子问题的结果。这样每个子问题都会先查找备忘录中是否存储了当前子问题的结果，如果已经有，就直接返回即可，否则进行递归计算。

```java
int coinChange(int[] coins, int amount) {
    int[] memo = new int[amount + 1];
    Arrays.fill(memo, -100);
    return dp(coins, amount, memo);
}
int dp(int[] coins, int n, int[] memo) {
    if (n == 0) return 0;
    if (n < 0) return -1; // 无解
    if (memo[n] != -100) return memo[n];
    int ans = Integer.MAX_VALUE;
    for (int coin : coins) {
        int subProblem = dp(coins, amount - coin);
        if (subProblem == -1) continue; // 子问题无解，跳过这个子问题
        ans = Math.min(ans, subProblem + 1);
    }
    if (ans == Integer.MAX_VALUE) return -1;
    memo[n] = ans;
    return ans;
}
```

​		上述算法，可以将递归树中大部分重复的计算都剪去。



## 例题

### 最长递增子序列

#### 题目描述

​		输入一个无序的整数数组，请你找到其中最长的严格递增子序列的长度。

> 子序列和子串的区别：子串一定是连续的，但是子序列可以不是连续的，只要相对顺序是一致的即可。

#### 解题过程

​		首先定义`dp(n)`数组的含义。在本题中，可以将其定义为*以下标为`n`的元素结尾的、最长的递增子序列*。

​		然后，确定base case，即`dp(0)`。在上述定义下，`dp(0)`是指，以`nums[0]`为结尾的，最长的子序列的长度。即`dp(0) = 1`。

​		接着，按照科学归纳法，即已知`dp(i)`，如何推出`dp(i + 1)`。在本题中，如果已知`dp(1...i)`，则可以遍历获取$nums[k] < nums[i + 1], and\ max(dp(k)), k \in [1, i]$。然后将最大的`dp(k)`直接+1，即可求得`dp(i + 1)`。

```java
public int dynamicProcessing(int[] nums, int[] dp, int n) {
    if (n == 0) return 1;
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
		if (nums[i] < nums[n]) {
            if (dp[i] == -1) dynamicProcessing(nums, dp, i);
            max = dp[i] > max ? dp[i] : max;
        }
    }
    dp[n] = max == Integer.MIN_VALUE ? 1 : max + 1;
    return dp[n];
}
```

#### 二维拓展

​		俄罗斯套娃信封问题：

> ​		给你一个二维整数数组 `envelopes` ，其中 `envelopes[i] = [wi, hi]` ，表示第 `i` 个信封的宽度和高度。
>
> ​		当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。
>
> ​		请计算 **最多能有多少个** 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。
>
> **注意**：不允许旋转信封。

​		这是对最长递增子序列的扩展，只需要先对长度进行升序排序，当长度相同时，宽度按照降序排序。然后，在对宽度进行最长递增子序列的计算即可获得最多嵌套数。



### 跳台阶问题

#### 题目描述

​		一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法(先后次序不同算不同的结果)。

#### 解题过程

​		首先，对`dp(n)`进行定义。本题中，可以直接将`dp(n)`定义为上到第n级台阶的跳法数量。

​		然后，确定base case。本题中，`dp(0) = 1`，`dp(1) = 1` 。

​		接着，如果已知`dp(1...i)`，如何求解`dp(i + 1)`。达到第i+1级台阶的上一步，只有两种可能，即从第i级走一步，或从第i-1级一次到达。两种情况正好对应两种不一样的走法。因此，`dp(i) = dp(i - 1) + dp(i - 2);`

```java
public void dp(int n) {
    if (n <= 1) return 1;
    return dp(n - 1) + dp(n - 2);
}
```

#### 带备忘录的优化

​		如果将递归树画出，可以看出存在着非常严重的重复计算，即重叠子问题。而只需要借助备忘录数组，将计算过的结果存储起来即可。

```java
public int dp(int[] memo, int number) {
    if (number <= 1) return 1;
    if (memo[number] != 0) return memo[number];
    memo[number] = dp(memo, number - 1) + dp(memo, number - 2);
    return memo[number];
}
```

 

### 最小花费爬楼梯

#### 题目描述

​		给定一个整数数组`cost[]` ，其中`cost[i]`是从楼梯第*i* 个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

​		你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

​		请你计算并返回达到楼梯顶部的最低花费。

#### 解题过程

​		首先，定义`dp(n)`。本题中，可以定义`dp(n)`表示上到第n级台阶的最小花费。

​		然后，确定base case。本题中，可以选择从下表为0或下标为1的位置开始爬，因此`dp(0)=0` `dp(1)=0`。

​		接着，已知`dp(1..i)`，如何推导出`dp(i)`。本题中，有`dp(i) = min(dp(i - 1) + cost[i - 1], dp(i - 2) + cost[i - 2])`。即从第i-1级爬一级的花费和从第i-2级爬两级的花费，两者取最小值。

```java
public int dp(int[] cost, int n) {
    // 本题中，n == cost.length
    if (n <= 1) return 0;
    return Math.min(dp(n - 1) + cost[n - 1], dp(n - 2) + cost[n - 2]);
}
```

#### 带备忘录的优化

​		可以看出，存在非常多的重复计算。因此，可以借助备忘录数组，将计算过的值保存下来，减少重复递归。

```java
private int dp(int[] cost, int[] memo, int n) {
	if (n == 0 || n == 1) return memo[n];
	if (memo[n - 1] == -1) {
		memo[n - 1] = dp(cost, memo, n - 1);
    }
	if (memo[n - 2] == -1) {
		memo[n - 2] = dp(cost, memo, n - 2);
	}
	return Math.min(memo[n - 1] + cost[n - 1], memo[n - 2] + cost[n - 2]);
}
```



### 最大子数组

#### 题目描述

​		给你输入一个整数数组 `nums`，请你找在其中找一个和最大的子数组，返回这个子数组的和。

​		子数组必须连续。

#### 解题过程

​		首先，定义`dp(n)`的含义。如果直接定义为`nums[0...n]`中的最大子数组和为`dp(n)`。那么，`dp(n)`之间是没有任何关系的。所以，将`dp(n)`定义为，以`nums[n]`结尾的最大子数组的和为`dp(n)`。

​		然后，找到base case。`dp(0) = nums[0]`。

​		接着，如何通过`dp(0...i)`推出`dp(i+1)`。对于`dp(i+1)`有两种选择，要么和前面相邻的子数组组合，形成一个新的子数组。要么自己作为一个新的数组。由此，`dp(i + 1) = max(dp(i )+nums[i], nums[i])`。

```java
int maxSubArray(int[] nums) {
    int n = nums.length;
    if (n == 0) return 0;
    // 定义：dp[i] 记录以 nums[i] 为结尾的「最大子数组和」
    int[] dp = new int[n];
    // base case
    // 第一个元素前面没有子数组
    dp[0] = nums[0];
    // 状态转移方程
    for (int i = 1; i < n; i++) {
        dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
    }
    // 得到 nums 的最大子数组
    int res = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}
```



#### 滑动窗口解法

​		初始状态下，窗口长度为1，`left = 0, right = 0`。

​		当窗口内元素之和大于等于零时，扩大窗口，即`right++`。

​		当窗口内元素之和小于零时，缩小窗口，即`left++`。

​		当窗口内元素有正有负时，则最大子数组一定是以整数开头，正数结尾的。因为，如果以负数开头结尾，则去掉开头结尾一定会得到更大的子数组。