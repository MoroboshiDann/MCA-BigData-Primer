# 贪心算法

## 什么是贪心算法

​		每个阶段都取得局部最优解，最终取得了全局最优解。

## 贪心的套路

​		贪心无套路。

​		先想出局部最优的解法，而且这个局部最优的方法没有反例，就可以尝试贪心算法。

## 例题

### 1. 分发饼干

#### 问题描述

​		两个数组，一个数组表示每个小孩子的胃口，另一个数组表示每个饼干的规格。问怎么样分发饼干能够满足最多的小孩。

#### 思路分析

​		对于每个饼干来说，尽量分发给胃口最大的小孩，这样能够最大限度利用饼干的规格。所以，每拿到一个饼干，去找它能满足的胃口最大的小孩。

​		则首先，应该对两个数组排序，然后遍历饼干数组，对于每个饼干，逆序遍历胃口数组，如果能够满足则结束内层遍历，否则继续。对于已经满足的小孩，应当作出标记。

```java
public class Solution {
    public int maxSatisfied(int[] appetite, int[] scale) {
        Arrays.sort(appetite);
        Arrays.sort(scale);
        int ans = 0;
        int index = appetite.length;
        for (int i = scale.length - 1; i >= 0; i--) {
            while (index >= 0 && appetite[index] > scale[i]) {
                index--;
            }
            if (index < 0) break;
            ans++;
        }
        return ans;
    }
}
```



# 动态规划

## 状态转移方程

​		描述问题结构的数学公式。如斐波那契数列问题中，元素值与元素索引的关系为：
$$
f(n) =  1 , n = 1, 2 \\
f(n) = f(n - 1) + f(n - 2), n > 2
$$
​		其中，n就是状态，从0一直变化至n。

## 解题步骤

​		以凑零钱问题为例，展示解题步骤。

> 题目描述：
>
> ​		给你 `k` 种面值的硬币，面值分别为 `c1, c2 ... ck`，每种硬币的数量无限，再给一个总金额 `amount`，问你**最少**需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。

​		首先，对于动态规划问题，要先找到暴力解，然后再进行优化。

​		对于动态规划问题，需要具有**最优子结构**。符合**最优子结构**，子问题之间需要相互独立。

​		而对于本题，零钱数量是无限的，所以，子问题之间没有任何制约。想要求`amount = 11`的问题，只需要知道如何凑出`amount = 10 `就可以直接将子问题的答案加1即可。



### 1. 确定base case

​		即当n=0时，方法的返回值为多少

### 2. 确定状态

​		状态，**也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。

### 3. 确定选择

​		**也就是导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

### 4. 明确`dp`函数/数组的定义

​		我们这里讲的是自顶向下的解法，所以会有一个递归的 `dp` 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。

​		**所以我们可以这样定义 `dp` 函数：`dp(n)` 表示，输入一个目标金额 `n`，返回凑出目标金额 `n` 所需的最少硬币数量**。



​		基于以上分析，可以先将题解的伪代码列出：

```java
int coinChange(int[] coins, int amount) {
	// 题目要求的最终结果的状态是，n = amount
    return dp(coins, amount);
}
int dp(int[] coins, int n) {
    // 做选择，原则需要硬币数量最小的结果
    for (int coin : coins) {
        ans = min(ans, 1 + dp(coins, n - coin));
    }
    return ans;
}
```

​		根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：

```java
int coinChange(int[] coins, int amount) {
    return dp(coins, amount);
}
int dp(int[] coins, int n) {
    if (n == 0) return 0;
    if (n < 0) return -1; // 无解
    int ans = Integer.MAX_VALUE;
    for (int coin : coins) {
        int subProblem = dp(coins, amount - coin);
        if (subProblem == -1) continue; // 子问题无解，跳过这个子问题
        ans = Math.min(ans, subProblem + 1);
    }
    return ans == Integer.MAX_VALUE ? -1 : ans;
}
```

​		至此，可以列出状态转移方程
$$
f(n) = \left\{
\begin{aligned}
0 & , & n = 0;\\
-1 & , & n < 0;\\
min(f(n - coin) + 1 | coin \in coins), n > 0;
\end{aligned}
\right.
$$

## 优化

### 1. 带备忘录的递归

​		经过上述分析，已经可以通过暴力递归来将问题解决了，我们可以画出递归树，看到重叠子问题。

然后结合之前斐波那契的例子，就可先通过带备忘录的递归来进行优化。

> 画出递归树，可以观察到，有很多子问题是被重复计算的。而如果我们添加一个备忘录，用来记录子问题的结果。这样每个子问题都会先查找备忘录中是否存储了当前子问题的结果，如果已经有，就直接返回即可，否则进行递归计算。

```java
int coinChange(int[] coins, int amount) {
    int[] memo = new int[amount + 1];
    Arrays.fill(memo, -100);
    return dp(coins, amount, memo);
}
int dp(int[] coins, int n, int[] memo) {
    if (n == 0) return 0;
    if (n < 0) return -1; // 无解
    if (memo[n] != -100) return memo[n];
    int ans = Integer.MAX_VALUE;
    for (int coin : coins) {
        int subProblem = dp(coins, amount - coin);
        if (subProblem == -1) continue; // 子问题无解，跳过这个子问题
        ans = Math.min(ans, subProblem + 1);
    }
    if (ans == Integer.MAX_VALUE) return -1;
    memo[n] = ans;
    return ans;
}
```

​		上述算法，可以将递归树中大部分重复的计算都剪去。