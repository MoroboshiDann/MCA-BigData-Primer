# 基础知识

## 常见的常数时间操作

- 算术运算(+, -, *, /, %)
- 位运算(>>, >>>, <<, |, &, ^)
- 赋值、比较、自增、自减操作等
- 数组寻址

总之，执行时间固定的操作就是常数时间操作；执行时间不固定的，都不是常数时间操作。

## 时间复杂度

时间复杂度，只需要关注最差情况下的复杂度

## 额外空间复杂度

除了题目必须的空间，为了完成目标额外申请的空间

## 对数器

使用一个系统提供的或者自己编写的一定正确的方法，与自己构思的方法进行对比。使用随机数组进行大量重复。

```java
public static int[] generateRandomArray(int maxSize, int maxValue) {
	int[] arr = new int[(int)((maxSize + 1) * Math.random())]; // 长度随机
    for (int i = 0; i < arr.length; i++) {
        arr[i] = (int)((maxValue + 1) * Math.random())
            - (int)((maxValue + 1) * Math.random()); // 随机赋值
    }
    return arr;
}
```



# 查找

## 二分法

### 有序数组

对于有序数组，可以采用二分查找，时间复杂度$O(logN)$

如果数组长度过大，进行二分时采用$(L+R)/2$ 可能会导致溢出而无法正确计算出中间位置，因此应当采用$L+(R-L)>>1$。右移是因为比除法更快。

### 无序数组

无序数组，任意两个相邻的数不相等，当一个数比相邻的两个数都小时，称之为局部最小

无序数组寻找局部最小时可以使用二分法，先检查两端是否满足局部最小，如果是直接返回，否则查看中间位置，如果中间位置为局部最小，直接返回，否则继续寻找比中间位置小的那一侧。

如此往复一定能找到局部最小，否则，会出现冲突。



# 排序

## 插入排序

在最差情况下(数组降序)，如果数组arr的长度为N，插入排序的每一步常数操作的数量，如同等差数列一般，$总的常数操作数量 = a * (N^2) + b * N + c$，所以时间复杂度为$O(N^2)$



# 位运算

## 异或

相同为零，不同为一。或者可以记忆为无进位加法。

即满足交换律又满足结合律

### 不借助额外空间交换两个数

```java
public static void swap(int[] arr, int i, int j) {
    if (i == j) return;
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
}
```

假设`a = A;b = B;`则，上述三个式子可以等效为`b = (A ^ B) ^ B;`则`b = A;`，`a = (A ^ B) ^ A;`

> i和j不能是同一个位置，否则无法正常交换

### 找到数组中出现奇数次的数(仅有一个)

- 哈希表
- 异或
  - 申请一个变量`eor = 0;`，使用该变量依次与数组中的所有数进行异或，最终的值就是出现了奇数次的数。

> 因为异或遵循交换律和结合律。又一个数与自身的异或结果为0，且0与任何数异或结果都为该数本身。

### 将int型的数最右侧的1提取出来

`a & (~a)`即可获得最右边的1，其余位为0的数。

> 因为`a & (~a + 1) = 0`

### 数组中有两个数出现了奇数次，其余数都出现了偶数次

申请一个变量`eor = 0`然后依次与数组中的数进行异或，则最终结果为`eor = a ^ b;`

此时使用`c = eor & (~eor)`即可获得eor最右边的一位1。则可以说明a, b在这一位上不相同

则使用eor分别与这一位上为0和为1的数进行异或，即可获得两个数

### 数组中只有一个数出现了K次，其余都出现了M次

M > 1, K < M，找出出现了K次的数

- 除了需要查找的数字，其余数字都出现了M次。说明如果将整数看作是32位二进制数字，将所有出现M次数字的对应位置直接相加，则最终结果，每个位置上的数值应当是M的整数倍
- 在上述基础上，再给对应位置加上出现K次的数字，则对应位置上的数值对M取余，结果不为零的表明需要查找的数字在该位置上为1



## push栈和pop栈实现顺序读取

设置两个栈push栈和pop栈，便可实现按照存入顺序读取数据。

数据先存储在push栈中，然后在从push中一次性全部转移到pop栈中，读取数据时，从pop栈中返回给用户即可。

原则：

- push栈需要一次性将内部的所有内容全部放入pop栈中
- pop栈中不为空时，不可以存入



## 两个单向队列模拟栈

push时，放到一个队列中，pop时，先将最后一个数据前的所有数据转移到另一个队列中，然后输出当前数据。接着，push时就需要将数据放入有数据的那个队列中



# Master公式

形如$T(N)=a*T(N/b)+O(N^d)$(其中a, b, d都是常数)的递归函数，可以通过Master公式来确定时间复杂度

- 如果$log_b a < d$，复杂度为$O(N^d)$
- 如果$log_b a > d$，复杂度为$O(N^{(log(b))})$
- 如果$log_b a = d$，复杂度为$O(N^d * logN)$

> 意思是，在递归函数中，调用递归的次数为a次，递归传入的参数量为当前函数的1/b
>
> 除了调用递归函数以外的处理逻辑的时间复杂度为O(N/d)



## 哈希表key的传递

如果是系统提供的引用类型，是按照值传递的

```java
Integer a = 10000000;
Integer b = 10000000;
HashMap<Integer, String> hashmap = new HashMap<>();
hashmap.put(a, "aaa");
sout(hasmap.containsKey(b)); // 输出true
sout(a == b); // 输出false，证明a和b的堆地址并不一致
```

如果是自定义类型，按照引用传递

```java
MyClass m1 = new MyClass(1);
MyClass m2 = new MyClass(1);
hashmap.put(m1, "m1");
sout(hashmap.containsKey(m2)); // 输出false1
```

